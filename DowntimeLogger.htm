<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Downtime Logger</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.15.0/Recharts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
</head>
<body class="bg-gray-100 font-sans">
  <div id="root" class="container mx-auto p-4"></div>

  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function loadFileData(filename) {
      try {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row =>
            row.some(cell => cell !== '' && cell !== null && cell !== undefined)
          );
          var csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData), { header: 1 });
          return csv;
        }
        return gk_fileData[filename] || "";
      } catch (e) {
        console.error('loadFileData error:', e);
        return "";
      }
    }
  </script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    class ErrorBoundary extends React.Component {
      state = { hasError: false, error: null };

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="text-center text-red-600 p-4">
              <h2 className="text-xl font-semibold">Something went wrong!</h2>
              <p>{this.state.error?.message || 'Unknown error'}</p>
              <button
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded-md"
                onClick={() => this.setState({ hasError: false, error: null })}
              >
                Try Again
              </button>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const lines = [
      { name: 'Line 1', section: 'PC Line' }, { name: 'Line 2', section: 'PC Line' },
      { name: 'Line 3', section: 'PC Line' }, { name: 'Line 4', section: 'PC Line' },
      { name: 'Line 5', section: 'PC Line' }, { name: 'Line 6', section: 'PC Line' },
      { name: 'Line 7', section: 'PC Line' },
      { name: 'Line 8', section: 'Pellet Lines' }, { name: 'Line 9', section: 'Pellet Lines' },
      { name: 'Line 10', section: 'Pellet Lines' }, { name: 'Line 11', section: 'Pellet Lines' },
      { name: 'Line 12', section: 'Extruded' }, { name: 'Line 13', section: 'Extruded' },
      { name: 'Line 14', section: 'Extruded' }, { name: 'Line 15', section: 'Extruded' },
      { name: 'Line 16', section: 'Extruded' },
      { name: 'Line 17', section: 'Hand Kettle' }, { name: 'Line 18', section: 'Hand Kettle' },
      { name: 'Line 19', section: 'Hand Kettle' }, { name: 'Line 20', section: 'Hand Kettle' },
      { name: 'Line 21', section: 'Hand Kettle' }, { name: 'Line 22', section: 'Hand Kettle' },
      { name: 'Line 23', section: 'Hand Kettle' },
      { name: 'Line 24', section: 'Twin Screw' }, { name: 'Line 25', section: 'Twin Screw' },
      { name: 'Line 26', section: 'Twin Screw' }, { name: 'Line 27', section: 'Twin Screw' },
      { name: 'Line 28', section: 'Twin Screw' }, { name: 'Line 29', section: 'Twin Screw' },
      { name: 'Line 30', section: 'Twin Screw' }, { name: 'Line 31', section: 'Twin Screw' },
      { name: 'Line 32', section: 'Sheeted 1' }, { name: 'Line 33', section: 'Sheeted 1' },
      { name: 'Line 34', section: 'Sheeted 1' }, { name: 'Line 35', section: 'Sheeted 1' },
      { name: 'Line 36', section: 'Sheeted 1' }, { name: 'Line 37', section: 'Sheeted 1' },
      { name: 'Line 38', section: 'Sheeted 2' }, { name: 'Line 39', section: 'Sheeted 2' }
    ];

    const defaultHeadData = Array(14).fill().map((_, i) => ({
      head: i + 1,
      offline: 'Active',
      issue: 'None',
      repaired: 'N/A',
      notes: ''
    }));

    const initialDates = [
      { id: 'day1', date: '2025-04-13', label: 'Day 1' },
      { id: 'day2', date: '2025-04-14', label: 'Day 2' },
      { id: 'day3', date: '2025-04-15', label: 'Day 3' },
      { id: 'day4', date: '2025-04-16', label: 'Day 4' },
      { id: 'day5', date: '2025-04-17', label: 'Day 5' }
    ];

    const initialData = lines.reduce((acc, line) => {
      acc[line.name] = {
        '2025-04-13': { heads: [...defaultHeadData] },
        '2025-04-14': { heads: [...defaultHeadData] },
        '2025-04-15': { heads: [...defaultHeadData] },
        '2025-04-16': { heads: [...defaultHeadData] },
        '2025-04-17': { heads: [...defaultHeadData] },
        running: {
          '2025-04-13': 'No',
          '2025-04-14': 'No',
          '2025-04-15': 'No',
          '2025-04-16': 'No',
          '2025-04-17': 'No'
        }
      };
      return acc;
    }, {});

    const App = () => {
      const [data, setData] = useState(() => {
        try {
          const savedData = localStorage.getItem('downtimeLoggerData');
          return savedData ? JSON.parse(savedData) : initialData;
        } catch (e) {
          console.error('Error loading data from localStorage:', e);
          return initialData;
        }
      });
      const [dates, setDates] = useState(() => {
        try {
          const savedDates = localStorage.getItem('downtimeLoggerDates');
          return savedDates ? JSON.parse(savedDates) : initialDates;
        } catch (e) {
          console.error('Error loading dates from localStorage:', e);
          return initialDates;
        }
      });
      const [currentLine, setCurrentLine] = useState('Line 1');
      const [currentDay, setCurrentDay] = useState('2025-04-13');
      const [currentPage, setCurrentPage] = useState('main');
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [summaryDay, setSummaryDay] = useState(null);
      const [selectedSummaryDay, setSelectedSummaryDay] = useState('All Days');
      const [selectedRunningLinesDay, setSelectedRunningLinesDay] = useState('All Days');
      const [selectedIssueType, setSelectedIssueType] = useState('All Issues');

      const textareaRefs = useRef(defaultHeadData.map(() => React.createRef()));

      useEffect(() => {
        try {
          localStorage.setItem('downtimeLoggerData', JSON.stringify(data));
        } catch (e) {
          console.error('Failed to save data to localStorage:', e);
        }
      }, [data]);

      useEffect(() => {
        try {
          localStorage.setItem('downtimeLoggerDates', JSON.stringify(dates));
        } catch (e) {
          console.error('Failed to save dates to localStorage:', e);
        }
      }, [dates]);

      useEffect(() => {
        setTimeout(() => {
          setLoading(false);
        }, 500);
      }, []);

      const issueTypes = [
        'None',
        'Chute',
        'Operator',
        'Load Cell',
        'Detached Head',
        'Stepper Motor Error',
        'Hopper Issues',
        'Installed Wrong'
      ];

      const excelDateToJSDate = (serial) => {
        const utc_days = Math.floor(serial - 25569);
        const date = new Date(utc_days * 86400 * 1000);
        return date.toISOString().split('T')[0]; // Returns YYYY-MM-DD
      };

      const handleFileImport = async (event) => {
        try {
          const file = event.target.files[0];
          if (!file) {
            setError('No file selected.');
            return;
          }

          setLoading(true);
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const arrayBuffer = e.target.result;
              const workbook = XLSX.read(arrayBuffer, { type: 'array' });
              const sheet = workbook.Sheets[workbook.SheetNames[0]];
              const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });

              const newData = JSON.parse(JSON.stringify(initialData));
              const excelDates = ['45755', '45757', '45758', '45762', '45764'];
              const dateMap = {
                '45755': '2025-04-13',
                '45757': '2025-04-14',
                '45758': '2025-04-15',
                '45762': '2025-04-16',
                '45764': '2025-04-17'
              };

              // Process running status from "Day X Run" columns
              const runData = {};
              for (let row = 0; row < jsonData.length; row++) {
                if (jsonData[row][0]?.startsWith('Line')) {
                  const line = jsonData[row][0];
                  if (lines.some(l => l.name === line)) {
                    runData[line] = {};
                    for (let i = 0; i < excelDates.length; i++) {
                      const date = dateMap[excelDates[i]];
                      const status = jsonData[row][i + 1];
                      runData[line][date] = status === 'Running' ? 'Yes' : 'No';
                    }
                  }
                }
              }

              // Process head-specific data for offline status
              let currentLine = null;
              let currentDay = null;
              const headData = {};
              for (let row = 0; row < jsonData.length; row++) {
                const firstCell = jsonData[row][0]?.toString().trim();
                if (firstCell?.startsWith('Line')) {
                  currentLine = firstCell;
                  headData[currentLine] = headData[currentLine] || {};
                } else if (firstCell?.startsWith('DAY')) {
                  const dayMatch = firstCell.match(/DAY\s+(\d+)\s+(\d+)/);
                  if (dayMatch) {
                    currentDay = dateMap[dayMatch[2]];
                    headData[currentLine][currentDay] = headData[currentLine][currentDay] || { heads: [...defaultHeadData] };
                  }
                } else if (firstCell === 'Head' && currentLine && currentDay) {
                  // Map row to day based on position (B6:O6, B13:O13, etc.)
                  const dayRows = [6, 13, 20, 27, 34].map(r => r - 6); // Adjust for JSON indexing (0-based, skipping headers)
                  const currentRowIndex = row;
                  const dayIndex = dayRows.findIndex(r => {
                    // Check if this row matches a "Head" row for a day
                    const expectedRow = jsonData.findIndex((r, i) => i >= currentRowIndex && r[0] === 'Head' && i === currentRowIndex);
                    return expectedRow === currentRowIndex;
                  });
                  if (dayIndex !== -1 && dateMap[excelDates[dayIndex]]) {
                    currentDay = dateMap[excelDates[dayIndex]];
                    headData[currentLine][currentDay] = headData[currentLine][currentDay] || { heads: [...defaultHeadData] };
                    const heads = jsonData[row].slice(1, 15).map((val, idx) => ({
                      head: idx + 1,
                      offline: val === 'X' ? 'Offline' : 'Active',
                      issue: 'None', // Preserve default or existing issue
                      repaired: val === 'X' ? 'N/A' : 'N/A', // Preserve default
                      notes: '' // Preserve default or existing notes
                    }));
                    headData[currentLine][currentDay].heads = heads;
                  }
                }
              }

              // Update running status
              Object.keys(newData).forEach(line => {
                if (runData[line]) {
                  newData[line].running = { ...newData[line].running, ...runData[line] };
                }
              });

              // Update head data
              Object.keys(headData).forEach(line => {
                if (newData[line]) {
                  Object.keys(headData[line]).forEach(date => {
                    newData[line][date] = headData[line][date];
                  });
                }
              });

              setData(newData);
              setError(null);
              setLoading(false);
            } catch (err) {
              console.error('File parsing error:', err);
              setError('Failed to parse Excel file. Ensure it matches the expected format.');
              setLoading(false);
            }
          };
          reader.readAsArrayBuffer(file);
        } catch (err) {
          console.error('File import error:', err);
          setError('Failed to import file. Please try again.');
          setLoading(false);
        }
      };

      const handleDateChange = (dayId, newDate) => {
        try {
          if (!newDate || newDate === '') {
            setError('Please select a valid date.');
            return;
          }

          if (dates.some(d => d.date === newDate && d.id !== dayId)) {
            setError('This date is already used for another day.');
            return;
          }

          setError(null);

          const oldDate = dates.find(d => d.id === dayId)?.date;
          if (!oldDate || oldDate === newDate) return;

          setDates(prev => prev.map(d => d.id === dayId ? { ...d, date: newDate } : d));

          setData(prev => {
            const newData = {};
            Object.keys(prev).forEach(line => {
              newData[line] = { running: {} };
              Object.keys(prev[line].running).forEach(date => {
                newData[line].running[date === oldDate ? newDate : date] = prev[line].running[date];
              });
              Object.keys(prev[line]).forEach(date => {
                if (date !== 'running') {
                  newData[line][date === oldDate ? newDate : date] = prev[line][date];
                }
              });
            });
            return newData;
          });

          if (currentDay === oldDate) {
            setCurrentDay(newDate);
          }
        } catch (e) {
          console.error('handleDateChange error:', e);
          setError('Failed to update date. Please try again.');
        }
      };

      const handleDropdownChange = (headIndex, field, value) => {
        console.log(`handleDropdownChange: headIndex=${headIndex}, field=${field}, value=${value}`);
        try {
          setData(prev => {
            const newData = { ...prev };
            const lineData = { ...newData[currentLine] };
            const dayData = { ...lineData[currentDay], heads: [...(lineData[currentDay]?.heads || defaultHeadData)] };
            const headData = { ...dayData.heads[headIndex] };

            if (field === 'notes') {
              headData.notes = value.trim();
            } else {
              headData[field] = value;
              if (field === 'offline') {
                headData.issue = value === 'Active' ? 'None' : headData.issue;
                headData.repaired = value === 'Active' ? 'N/A' : headData.repaired;
                headData.notes = value === 'Active' ? '' : headData.notes;
              }
              if (field === 'issue') {
                headData.repaired = value === 'None' ? 'N/A' : headData.repaired;
                headData.notes = value === 'None' ? '' : headData.notes;
              }
            }

            dayData.heads[headIndex] = headData;
            lineData[currentDay] = dayData;
            newData[currentLine] = lineData;
            console.log('State updated for', currentLine, currentDay, headIndex);
            return newData;
          });
        } catch (e) {
          console.error('handleDropdownChange error:', e);
          setError('Failed to update data. Please try again.');
        }
      };

      const handleRunningChange = (value) => {
        try {
          setData(prev => {
            const newData = { ...prev };
            const lineData = { ...newData[currentLine] };
            lineData.running = { ...lineData.running, [currentDay]: value };
            newData[currentLine] = lineData;
            return newData;
          });
        } catch (e) {
          console.error('handleRunningChange error:', e);
          setError('Failed to update running status. Please try again.');
        }
      };

      const handleReset = () => {
        try {
          if (window.confirm('Are you sure you want to reset all data to defaults? This will clear all changes.')) {
            setData(initialData);
            setDates(initialDates);
            setCurrentLine('Line 1');
            setCurrentDay('2025-04-13');
            setSelectedSummaryDay('All Days');
            setSelectedRunningLinesDay('All Days');
            setSelectedIssueType('All Issues');
            try {
              localStorage.removeItem('downtimeLoggerData');
              localStorage.removeItem('downtimeLoggerDates');
            } catch (e) {
              console.error('Failed to clear localStorage:', e);
            }
          }
        } catch (e) {
          console.error('handleReset error:', e);
          setError('Failed to reset data. Please try again.');
        }
      };

      const exportToCSV = () => {
        try {
          const csvData = [];
          lines.forEach(line => {
            dates.forEach(day => {
              const row = {
                Line: line.name,
                Section: line.section,
                Date: day.date,
                Running: data[line.name].running[day.date] || 'No'
              };
              (data[line.name][day.date]?.heads || defaultHeadData).forEach(head => {
                row[`Head${head.head}_Offline`] = head.offline;
                row[`Head${head.head}_Issue`] = head.issue;
                row[`Head${head.head}_Repaired`] = head.repaired;
                row[`Head${head.head}_Notes`] = head.notes || '';
              });
              csvData.push(row);
            });
          });

          const csv = Papa.unparse(csvData);
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'Downtime_Log.csv';
          link.click();
        } catch (e) {
          console.error('exportToCSV error:', e);
          setError('Failed to export CSV. Please try again.');
        }
      };

      const exportToPDF = () => {
        try {
          console.log('Starting PDF export for day:', selectedSummaryDay);
          if (!window.jspdf || !window.jspdf.jsPDF) {
            console.error('jsPDF not loaded');
            setError('PDF library failed to load. Please try again.');
            return;
          }

          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();
          const pageWidth = doc.internal.pageSize.getWidth();
          let yOffset = 20;

          doc.setFontSize(16);
          doc.text('Ishida CCW Downtime Report', pageWidth / 2, yOffset, { align: 'center' });
          yOffset += 10;

          doc.setFontSize(12);
          const currentDate = new Date().toLocaleString();
          console.log('Adding date to PDF:', currentDate);
          doc.text(`Generated: ${currentDate}`, pageWidth / 2, yOffset, { align: 'center' });
          yOffset += 10;

          const dayLabel = selectedSummaryDay === 'All Days' ? 'All Days' : dates.find(d => d.date === selectedSummaryDay)?.label || selectedSummaryDay;
          console.log('Adding day label to PDF:', dayLabel);
          doc.text(`Day: ${dayLabel}${selectedSummaryDay !== 'All Days' ? ` (${selectedSummaryDay})` : ''}`, 20, yOffset);
          yOffset += 10;

          doc.setFontSize(14);
          doc.text('Overall Summary', 20, yOffset);
          yOffset += 10;
          doc.setFontSize(12);
          console.log('Adding metrics: lines running=', totalLinesRunning, 'heads offline=', totalHeadsDown);
          doc.text(`Total Lines Running: ${totalLinesRunning}`, 20, yOffset);
          yOffset += 5;
          doc.text(`Total Heads Offline: ${totalHeadsDown}`, 20, yOffset);
          yOffset += 10;

          console.log('Preparing Heads Down Summary data');
          const headsDownData = headsDownSummary
            .filter(entry => selectedSummaryDay === 'All Days' || entry.date === selectedSummaryDay)
            .map(entry => [
              entry.line || 'N/A',
              entry.section || 'N/A',
              `${entry.dayLabel} (${entry.date})`,
              entry.headsOffline.map(h => h.head).join(', ') || 'None',
              entry.headsOffline.map(h => h.issue).join(', ') || 'None',
              entry.headsOffline.map(h => h.repaired).join(', ') || 'None',
              entry.headsOffline.map(h => `Head ${h.head}: ${h.notes || 'None'}`).join('; ') || 'None'
            ]);

          console.log('Heads Down data:', headsDownData);
          doc.autoTable({
            head: [['Line', 'Section', 'Day', 'Heads Offline', 'Issues', 'Repaired', 'Notes']],
            body: headsDownData.length > 0 ? headsDownData : [['No offline heads recorded']],
            startY: yOffset,
            styles: { fontSize: 10 },
            headStyles: { fillColor: [59, 130, 246], textColor: [255, 255, 255] },
            bodyStyles: { minCellHeight: 10 }
          });

          doc.save(`Downtime_Report_${selectedSummaryDay.replace(/\s+/g, '_')}.pdf`);
        } catch (e) {
          console.error('exportToPDF error:', e);
          setError('Failed to export PDF. Please try again.');
        }
      };

      const totalHeadsDown = Object.keys(data).reduce((sum, line) => {
        return sum + dates.reduce((daySum, day) => {
          return daySum + (data[line][day.date]?.heads || defaultHeadData).filter(head => head.offline === 'Offline').length;
        }, 0);
      }, 0);

      const totalLinesRunning = Object.keys(data).reduce((sum, line) => {
        return sum + dates.reduce((daySum, day) => {
          return daySum + (data[line].running[day.date] === 'Yes' ? 1 : 0);
        }, 0);
      }, 0);

      const issueCounts = issueTypes
        .filter(issue => issue !== 'None')
        .map(issue => ({
          issue,
          count: Object.keys(data).reduce((sum, line) => {
            return sum + dates.reduce((daySum, day) => {
              return daySum + (data[line][day.date]?.heads || defaultHeadData).filter(head => head.issue === issue).length;
            }, 0);
          }, 0)
        }))
        .filter(ic => ic.count > 0);

      const activeLines = Object.keys(data).filter(line =>
        dates.some(day => (data[line][day.date]?.heads || defaultHeadData).some(head => head.offline === 'Offline'))
      );

      const headsDownSummary = lines.flatMap(line =>
        dates.map(day => {
          const headsOffline = (data[line.name][day.date]?.heads || defaultHeadData).filter(head => head.offline === 'Offline');
          return {
            line: line.name,
            section: line.section,
            date: day.date,
            dayLabel: day.label,
            headsOffline
          };
        })
      ).filter(entry => entry.headsOffline.length > 0);

      const totalHeadsDownPerDay = dates.map(day => ({
        day: day.label,
        date: day.date,
        heads: Object.keys(data).reduce((sum, line) => {
          return sum + (data[line][day.date]?.heads || defaultHeadData).filter(head => head.offline === 'Offline').length;
        }, 0)
      }));

      const runningLinesPerDay = dates.map(day => ({
        day: day.label,
        date: day.date,
        lines: Object.keys(data).reduce((sum, line) => {
          return sum + (data[line].running[day.date] === 'Yes' ? 1 : 0);
        }, 0)
      }));

      const issueTrends = dates.map(day => {
        const counts = { day: day.label };
        issueTypes.filter(issue => issue !== 'None').forEach(issue => {
          counts[issue] = Object.keys(data).reduce((sum, line) => {
            return sum + (data[line][day.date]?.heads || defaultHeadData).filter(head => head.issue === issue).length;
          }, 0);
        });
        return counts;
      });

      const DaySummaryModal = ({ dayLabel }) => {
        const day = dates.find(d => d.label === dayLabel);
        if (!day) return null;

        const daySummary = lines
          .map(line => {
            const headsOffline = (data[line.name][day.date]?.heads || defaultHeadData).filter(head => head.offline === 'Offline');
            return {
              line: line.name,
              section: line.section,
              headsOffline
            };
          })
          .filter(entry => entry.headsOffline.length > 0);

        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-lg max-w-4xl w-full max-h-[80vh] overflow-y-auto">
              <h2 className="text-2xl font-semibold mb-4">{dayLabel} Offline Summary ({day.date})</h2>
              <table className="min-w-full bg-white">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="px-4 py-2 text-left">Line</th>
                    <th className="px-4 py-2 text-left">Section</th>
                    <th className="px-4 py-2 text-left">Heads Offline</th>
                    <th className="px-4 py-2 text-left">Issues</th>
                    <th className="px-4 py-2 text-left">Repaired</th>
                    <th className="px-4 py-2 text-left">Notes</th>
                  </tr>
                </thead>
                <tbody>
                  {daySummary.length > 0 ? (
                    daySummary.map((entry, index) => (
                      <tr key={index} className="border-t">
                        <td className="px-4 py-2">{entry.line}</td>
                        <td className="px-4 py-2">{entry.section}</td>
                        <td className="px-4 py-2">{entry.headsOffline.map(h => h.head).join(', ') || 'None'}</td>
                        <td className="px-4 py-2">{entry.headsOffline.map(h => h.issue).join(', ') || 'None'}</td>
                        <td className="px-4 py-2">{entry.headsOffline.map(h => h.repaired).join(', ') || 'None'}</td>
                        <td className="px-4 py-2">{entry.headsOffline.map(h => `Head ${h.head}: ${h.notes || 'None'}`).join('; ') || 'None'}</td>
                      </tr>
                    ))
                  ) : (
                    <tr>
                      <td colSpan="6" className="px-4 py-2 text-center">No offline heads recorded.</td>
                    </tr>
                  )}
                </tbody>
              </table>
              <button
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                onClick={() => setSummaryDay(null)}
              >
                Close
              </button>
            </div>
          </div>
        );
      };

      const DashboardPage = () => (
        <div>
          <h2 className="text-2xl font-semibold mb-6">Real-Time Dashboard</h2>
          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h3 className="text-xl font-semibold mb-4">Line Status Overview</h3>
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
              {lines.map(line => (
                <div key={line.name} className="p-4 bg-gray-50 rounded-md">
                  <h4 className="font-medium">{line.section}: {line.name}</h4>
                  <p>Running: {data[line.name].running[currentDay] || 'No'}</p>
                  <p>Heads Down: {(data[line.name][currentDay]?.heads || defaultHeadData).filter(head => head.offline === 'Offline').length}</p>
                </div>
              ))}
            </div>
          </div>
        </div>
      );

      const SummaryPage = () => (
        <div>
          <h2 className="text-2xl font-semibold mb-6">Summary Page</h2>
          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h3 className="text-xl font-semibold mb-4">Heads Down Summary</h3>
            <div className="mb-4">
              <label className="block text-lg font-semibold mb-2">Select Day:</label>
              <select
                className="w-full p-2 border rounded-md"
                value={selectedSummaryDay}
                onChange={(e) => setSelectedSummaryDay(e.target.value)}
              >
                <option value="All Days">All Days</option>
                {dates.map(day => (
                  <option key={day.date} value={day.date}>{day.label} ({day.date})</option>
                ))}
              </select>
            </div>
            <table className="min-w-full bg-white">
              <thead>
                <tr className="bg-gray-200">
                  <th className="px-4 py-2 text-left">Line</th>
                  <th className="px-4 py-2 text-left">Section</th>
                  <th className="px-4 py-2 text-left">Day</th>
                  <th className="px-4 py-2 text-left">Heads Offline</th>
                  <th className="px-4 py-2 text-left">Issues</th>
                  <th className="px-4 py-2 text-left">Repaired</th>
                  <th className="px-4 py-2 text-left">Notes</th>
                </tr>
              </thead>
              <tbody>
                {headsDownSummary
                  .filter(entry => selectedSummaryDay === 'All Days' || entry.date === selectedSummaryDay)
                  .map((entry, index) => (
                    <tr key={index} className="border-t">
                      <td className="px-4 py-2">{entry.line}</td>
                      <td className="px-4 py-2">{entry.section}</td>
                      <td className="px-4 py-2">{entry.dayLabel} ({entry.date})</td>
                      <td className="px-4 py-2">{entry.headsOffline.map(h => h.head).join(', ') || 'None'}</td>
                      <td className="px-4 py-2">{entry.headsOffline.map(h => h.issue).join(', ') || 'None'}</td>
                      <td className="px-4 py-2">{entry.headsOffline.map(h => h.repaired).join(', ') || 'None'}</td>
                      <td className="px-4 py-2">{entry.headsOffline.map(h => `Head ${h.head}: ${h.notes || 'None'}`).join('; ') || 'None'}</td>
                    </tr>
                  ))}
                {headsDownSummary.filter(entry => selectedSummaryDay === 'All Days' || entry.date === selectedSummaryDay).length === 0 && (
                  <tr>
                    <td colSpan="7" className="px-4 py-2 text-center">No offline heads recorded.</td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h3 className="text-xl font-semibold mb-4">Running Lines Summary</h3>
            <div className="mb-4">
              <label className="block text-lg font-semibold mb-2">Select Day:</label>
              <select
                className="w-full p-2 border rounded-md"
                value={selectedRunningLinesDay}
                onChange={(e) => setSelectedRunningLinesDay(e.target.value)}
              >
                <option value="All Days">All Days</option>
                {dates.map(day => (
                  <option key={day.date} value={day.date}>{day.label} ({day.date})</option>
                ))}
              </select>
            </div>
            <table className="min-w-full bg-white">
              <thead>
                <tr className="bg-gray-200">
                  <th className="px-4 py-2 text-left">Day</th>
                  <th className="px-4 py-2 text-left">Lines Running</th>
                </tr>
              </thead>
              <tbody>
                {runningLinesPerDay
                  .filter(day => selectedRunningLinesDay === 'All Days' || day.date === selectedRunningLinesDay)
                  .map((day, index) => (
                    <tr key={index} className="border-t">
                      <td className="px-4 py-2">{day.day} ({day.date})</td>
                      <td className="px-4 py-2">{day.lines}</td>
                    </tr>
                  ))}
              </tbody>
            </table>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.BarChart
                data={runningLinesPerDay.filter(day => selectedRunningLinesDay === 'All Days' || day.date === selectedRunningLinesDay)}
              >
                <Recharts.CartesianGrid strokeDasharray="3 3" />
                <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                <Recharts.YAxis
                  label={{ value: 'Lines Running', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                  style={{ fontSize: 12 }}
                />
                <Recharts.Tooltip />
                <Recharts.Legend />
                <Recharts.Bar dataKey="lines" fill="#3b82f6" />
              </Recharts.BarChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h3 className="text-xl font-semibold mb-4">Issue Trends Over Time</h3>
            <div className="mb-4">
              <label className="block text-lg font-semibold mb-2">Select Issue Type:</label>
              <select
                className="w-full p-2 border rounded-md"
                value={selectedIssueType}
                onChange={(e) => {
                  console.log('Selected issue type:', e.target.value);
                  setSelectedIssueType(e.target.value);
                }}
              >
                <option value="All Issues">All Issues</option>
                {issueTypes.filter(issue => issue !== 'None').map(issue => (
                  <option key={issue} value={issue}>{issue}</option>
                ))}
              </select>
            </div>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.LineChart data={issueTrends}>
                <Recharts.CartesianGrid strokeDasharray="3 3" />
                <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                <Recharts.YAxis
                  label={{ value: 'Issue Count', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                  style={{ fontSize: 12 }}
                />
                <Recharts.Tooltip />
                <Recharts.Legend />
                {issueTypes
                  .filter(issue => issue !== 'None' && (selectedIssueType === 'All Issues' || selectedIssueType === issue))
                  .map((issue, index) => (
                    <Recharts.Line
                      key={issue}
                      type="monotone"
                      dataKey={issue}
                      stroke={['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#f97316'][index % 7]}
                      name={issue}
                    />
                  ))}
              </Recharts.LineChart>
            </Recharts.ResponsiveContainer>
          </div>
        </div>
      );

      const MainPage = () => (
        <div>
          {error && (
            <div className="bg-red-100 text-red-700 p-4 rounded-md mb-8">
              {error}
            </div>
          )}

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Manage Dates</h2>
              <button
                className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                onClick={handleReset}
              >
                Reset to Defaults
              </button>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
              {dates.map(day => (
                <div key={day.id}>
                  <label className="block text-sm font-medium mb-1">{day.label}</label>
                  <input
                    type="date"
                    className="w-full p-2 border rounded-md"
                    value={day.date}
                    onChange={(e) => handleDateChange(day.id, e.target.value)}
                  />
                </div>
              ))}
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Import Data</h2>
            <input
              type="file"
              accept=".csv,.xlsx"
              className="w-full p-2 border rounded-md"
              onChange={handleFileImport}
            />
            <p className="text-sm text-gray-500 mt-2">
              Upload a CSV/XLSX file with columns: Line, Section, Date, Running, Head1_Offline, Head1_Issue, Head1_Repaired, Head1_Notes, ..., Head14_Notes
            </p>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Select Line:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={currentLine}
              onChange={(e) => setCurrentLine(e.target.value)}
            >
              {lines.map(line => (
                <option key={line.name} value={line.name}>
                  {line.section}: {line.name}
                </option>
              ))}
            </select>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Select Day:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={currentDay}
              onChange={(e) => setCurrentDay(e.target.value)}
            >
              {dates.map(day => (
                <option key={day.date} value={day.date}>
                  {day.label} ({day.date})
                </option>
              ))}
            </select>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Is {currentLine} Running?</label>
            <select
              className="w-full p-2 border rounded-md"
              value={data[currentLine].running[currentDay] || 'No'}
              onChange={(e) => handleRunningChange(e.target.value)}
            >
              <option value="No">No</option>
              <option value="Yes">Yes</option>
              <option value="N/A">N/A</option>
            </select>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">
              {currentLine} - Head Status ({currentDay})
            </h2>
            <div className="overflow-x-auto">
              <table className="min-w-full bg-white">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="px-4 py-2 text-left">Head</th>
                    <th className="px-4 py-2 text-left">Offline Status</th>
                    <th className="px-4 py-2 text-left">Issue Type</th>
                    <th className="px-4 py-2 text-left">Repaired</th>
                    <th className="px-4 py-2 text-left">Notes</th>
                  </tr>
                </thead>
                <tbody>
                  {(data[currentLine][currentDay]?.heads || defaultHeadData).map((head, index) => (
                    <tr key={`head-${head.head}-${currentLine}-${currentDay}`} className="border-t">
                      <td className="px-4 py-2">{head.head}</td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.offline}
                          onChange={(e) => handleDropdownChange(index, 'offline', e.target.value)}
                        >
                          <option value="Active">Active</option>
                          <option value="Offline">Offline</option>
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.issue}
                          onChange={(e) => handleDropdownChange(index, 'issue', e.target.value)}
                          disabled={head.offline !== 'Offline'}
                        >
                          {issueTypes.map(type => (
                            <option key={type} value={type}>{type}</option>
                          ))}
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.repaired}
                          onChange={(e) => handleDropdownChange(index, 'repaired', e.target.value)}
                          disabled={head.offline !== 'Offline' || head.issue === 'None'}
                        >
                          <option value="N/A">N/A</option>
                          <option value="Fixed">Fixed</option>
                          <option value="Not Fixed">Not Fixed</option>
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <input
                          type="text"
                          className="w-full p-1 border rounded-md"
                          defaultValue={head.notes || ''}
                          ref={textareaRefs.current[index]}
                          maxLength="200"
                          placeholder="Notes (max 200 chars)"
                          disabled={head.offline !== 'Offline'}
                          onBlur={(e) => {
                            console.log(`Notes blur: head=${head.head}, value=${e.target.value}`);
                            handleDropdownChange(index, 'notes', e.target.value);
                          }}
                          onTouchStart={(e) => {
                            console.log(`Notes touch: head=${head.head}`);
                            e.target.focus();
                          }}
                          onClick={(e) => {
                            console.log(`Notes click: head=${head.head}`);
                            e.target.focus();
                          }}
                        />
                        <p className="text-xs text-gray-500 mt-1">
                          {(head.notes || '').length}/200
                        </p>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Heads Down Per Day ({currentLine})</h2>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.BarChart data={totalHeadsDownPerDay}>
                <Recharts.CartesianGrid strokeDasharray="3 3" />
                <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                <Recharts.YAxis
                  label={{ value: 'Heads Down', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                  style={{ fontSize: 12 }}
                />
                <Recharts.Tooltip />
                <Recharts.Legend />
                <Recharts.Bar dataKey="heads" fill="#3b82f6" />
              </Recharts.BarChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Issue Distribution (All Lines)</h2>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.PieChart>
                <Recharts.Pie
                  data={issueCounts}
                  dataKey="count"
                  nameKey="issue"
                  cx="50%"
                  cy="50%"
                  outerRadius={80}
                  fill="#10b981"
                  label
                  style={{ fontSize: 12 }}
                >
                  {issueCounts.map((entry, index) => (
                    <Recharts.Cell key={`cell-${index}`} fill={['#10b981', '#ef4444', '#f59e0b'][index % 3]} />
                  ))}
                </Recharts.Pie>
                <Recharts.Tooltip />
                <Recharts.Legend />
              </Recharts.PieChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Summary</h2>
              <div className="flex flex-wrap gap-2">
                {dates.map(day => (
                  <button
                    key={day.label}
                    className="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600"
                    onClick={() => setSummaryDay(day.label)}
                  >
                    {day.label} Offline Summary
                  </button>
                ))}
                <button
                  className="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                  onClick={exportToCSV}
                >
                  Export to CSV
                </button>
                <button
                  className="bg-purple-500 text-white px-4 py-2 rounded-md hover:bg-purple-600"
                  onClick={exportToPDF}
                >
                  Download PDF Report
                </button>
              </div>
            </div>
            <p className="text-gray-600">
              Total heads down across all lines and days: {totalHeadsDown}.<br />
              Issues recorded: {issueCounts.map(ic => `${ic.issue}: ${ic.count}`).join(', ') || 'None'}.<br />
              Active lines with downtime: {activeLines.length > 0 ? activeLines.join(', ') : 'None'}.<br />
              {activeLines.length > 0
                ? `Downtime is recorded across ${activeLines.length} line(s). Update statuses using the dropdowns to log new issues.`
                : `No downtime recorded. Update statuses using the dropdowns to log issues.`}
            </p>
          </div>

          {summaryDay && <DaySummaryModal dayLabel={summaryDay} />}
        </div>
      );

      if (loading) {
        return (
          <div className="text-center text-2xl font-semibold text-gray-600 mt-10">
            Loading data...
          </div>
        );
      }

      return (
        <ErrorBoundary>
          <div className="max-w-7xl mx-auto">
            <h1 className="text-3xl font-bold text-gray-800 mb-8 text-center">
              Manufacturing Downtime Logger
            </h1>

            <div className="flex mb-8">
              <button
                className={`px-4 py-2 mr-2 rounded-md ${currentPage === 'main' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('main')}
              >
                Main Logger
              </button>
              <button
                className={`px-4 py-2 mr-2 rounded-md ${currentPage === 'summary' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('summary')}
              >
                Summary Page
              </button>
              <button
                className={`px-4 py-2 rounded-md ${currentPage === 'dashboard' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('dashboard')}
              >
                Dashboard
              </button>
            </div>

            {currentPage === 'main' ? <MainPage /> : currentPage === 'dashboard' ? <DashboardPage /> : <SummaryPage />}
          </div>
        </ErrorBoundary>
      );
    };

    try {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    } catch (e) {
      console.error('Root render error:', e);
      document.getElementById('root').innerHTML = '<div className="text-center text-red-600 p-4">Failed to load app. Please refresh and try again.</div>';
    }
  </script>
</body>
</html>
