<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>Downtime Logger</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.5">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min

-height: 14.0px}
  </style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.15.0/Recharts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
</head>
<body class="bg-gray-100 font-sans">
  <div id="root" class="container mx-auto p-4"></div>

  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function loadFileData(filename) {
      try {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row =>
            row.some(cell => cell !== '' && cell !== null && cell !== undefined)
          );
          var csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData), { header: 1 });
          return csv;
        }
        return gk_fileData[filename] || "";
      } catch (e) {
        console.error('loadFileData error:', e);
        return "";
      }
    }
  </script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    class ErrorBoundary extends React.Component {
      state = { hasError: false, error: null };

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="text-center text-red-600 p-4">
              <h2 className="text-xl font-semibold">Something went wrong!</h2>
              <p>{this.state.error?.message || 'Unknown error'}</p>
              <button
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded-md"
                onClick={() => this.setState({ hasError: false, error: null })}
              >
                Try Again
              </button>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const lines = [
      { name: 'Line 1', section: 'PC Line' }, { name: 'Line 2', section: 'PC Line' },
      { name: 'Line 3', section: 'PC Line' }, { name: 'Line 4', section: 'PC Line' },
      { name: 'Line 5', section: 'PC Line' }, { name: 'Line 6', section: 'PC Line' },
      { name: 'Line 7', section: 'PC Line' },
      { name: 'Line 8', section: 'Pellet Lines' }, { name: 'Line 9', section: 'Pellet Lines' },
      { name: 'Line 10', section: 'Pellet Lines' }, { name: 'Line 11', section: 'Pellet Lines' },
      { name: 'Line 12', section: 'Extruded' }, { name: 'Line 13', section: 'Extruded' },
      { name: 'Line 14', section: 'Extruded' }, { name: 'Line 15', section: 'Extruded' },
      { name: 'Line 16', section: 'Extruded' },
      { name: 'Line 17', section: 'Hand Kettle' }, { name: 'Line 18', section: 'Hand Kettle' },
      { name: 'Line 19', section: 'Hand Kettle' }, { name: 'Line 20', section: 'Hand Kettle' },
      { name: 'Line 21', section: 'Hand Kettle' }, { name: 'Line 22', section: 'Hand Kettle' },
      { name: 'Line 23', section: 'Hand Kettle' },
      { name: 'Line 24', section: 'Twin Screw' }, { name: 'Line 25', section: 'Twin Screw' },
      { name: 'Line 26', section: 'Twin Screw' }, { name: 'Line 27', section: 'Twin Screw' },
      { name: 'Line 28', section: 'Twin Screw' }, { name: 'Line 29', section: 'Twin Screw' },
      { name: 'Line 30', section: 'Twin Screw' }, { name: 'Line 31', section: 'Twin Screw' },
      { name: 'Line 32', section: 'Sheeted 1' }, { name: 'Line 33', section: 'Sheeted 1' },
      { name: 'Line 34', section: 'Sheeted 1' }, { name: 'Line 35', section: 'Sheeted 1' },
      { name: 'Line 36', section: 'Sheeted 1' }, { name: 'Line 37', section: 'Sheeted 1' },
      { name: 'Line 38', section: 'Sheeted 2' }, { name: 'Line 39', section: 'Sheeted 2' }
    ];

    const defaultHeadData = Array(14).fill().map((_, i) => ({
      head: i + 1,
      offline: 'Active',
      issue: 'None',
      repaired: 'N/A',
      notes: ''
    }));

    const initialDates = [
      { id: 'day1', date: '2025-04-13', label: 'Day 1' },
      { id: 'day2', date: '2025-04-14', label: 'Day 2' },
      { id: 'day3', date: '2025-04-15', label: 'Day 3' },
      { id: 'day4', date: '2025-04-16', label: 'Day 4' },
      { id: 'day5', date: '2025-04-17', label: 'Day 5' }
    ];

    const initialData = lines.reduce((acc, line) => {
      acc[line.name] = {
        '2025-04-13': { heads: [...defaultHeadData] },
        '2025-04-14': { heads: [...defaultHeadData] },
        '2025-04-15': { heads: [...defaultHeadData] },
        '2025-04-16': { heads: [...defaultHeadData] },
        '2025-04-17': { heads: [...defaultHeadData] },
        running: {
          '2025-04-13': 'No',
          '2025-04-14': 'No',
          '2025-04-15': 'No',
          '2025-04-16': 'No',
          '2025-04-17': 'No'
        }
      };
      return acc;
    }, {});

    const App = () => {
      const [data, setData] = useState(() => {
        try {
          const savedData = localStorage.getItem('downtimeLoggerData');
          return savedData ? JSON.parse(savedData) : initialData;
        } catch (e) {
          console.error('Error loading data from localStorage:', e);
          return initialData;
        }
      });
      const [dates, setDates] = useState(() => {
        try {
          const savedDates = localStorage.getItem('downtimeLoggerDates');
          return savedDates ? JSON.parse(savedDates) : initialDates;
        } catch (e) {
          console.error('Error loading dates from localStorage:', e);
          return initialDates;
        }
      });
      const [historyLog, setHistoryLog] = useState(() => {
        try {
          const savedHistory = localStorage.getItem('downtimeLoggerHistory');
          return savedHistory ? JSON.parse(savedHistory) : [];
        } catch (e) {
          console.error('Error loading history from localStorage:', e);
          return [];
        }
      });
      const [currentLine, setCurrentLine] = useState('Line 1');
      const [currentDay, setCurrentDay] = useState('2025-04-13');
      const [currentPage, setCurrentPage] = useState('main');
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [summaryDay, setSummaryDay] = useState(null);
      const [selectedSummaryDay, setSelectedSummaryDay] = useState('All Days');
      const [selectedRunningLinesDay, setSelectedRunningLinesDay] = useState('All Days');
      const [selectedIssueType, setSelectedIssueType] = useState('All Issues');
      const [selectedHistoryLine, setSelectedHistoryLine] = useState('All Lines');
      const [selectedHistoryHead, setSelectedHistoryHead] = useState('All Heads');
      const [selectedDashboardDay, setSelectedDashboardDay] = useState('All Days');

      const textareaRefs = useRef(defaultHeadData.map(() => React.createRef()));
      const pendingHistoryUpdates = useRef({});

      useEffect(() => {
        try {
          localStorage.setItem('downtimeLoggerData', JSON.stringify(data));
        } catch (e) {
          console.error('Failed to save data to localStorage:', e);
        }
      }, [data]);

      useEffect(() => {
        try {
          localStorage.setItem('downtimeLoggerDates', JSON.stringify(dates));
        } catch (e) {
          console.error('Failed to save dates to localStorage:', e);
        }
      }, [dates]);

      useEffect(() => {
        try {
          localStorage.setItem('downtimeLoggerHistory', JSON.stringify(historyLog));
        } catch (e) {
          console.error('Failed to save history to localStorage:', e);
        }
      }, [historyLog]);

      useEffect(() => {
        setTimeout(() => {
          setLoading(false);
        }, 500);
      }, []);

      const issueTypes = [
        'None',
        'Chute',
        'Operator',
        'Load Cell',
        'Detached Head',
        'Stepper Motor Error',
        'Hopper Issues',
        'Installed Wrong'
      ];

      const excelDateToJSDate = (serial) => {
        const utc_days = Math.floor(serial - 25569);
        const date = new Date(utc_days * 86400 * 1000);
        return date.toISOString().split('T')[0];
      };

      const handleFileImport = async (event) => {
        try {
          const file = event.target.files[0];
          if (!file) {
            setError('No file selected.');
            return;
          }

          setLoading(true);
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const arrayBuffer = e.target.result;
              const workbook = XLSX.read(arrayBuffer, { type: 'array' });
              const sheet = workbook.Sheets[workbook.SheetNames[0]];
              const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false, defval: '' });

              const newData = JSON.parse(JSON.stringify(initialData));
              const excelDates = ['45755', '45757', '45758', '45762', '45764'];
              const dateMap = {
                '45755': '2025-04-13',
                '45757': '2025-04-14',
                '45758': '2025-04-15',
                '45762': '2025-04-16',
                '45764': '2025-04-17'
              };

              const runData = {};
              for (let row = 0; row < jsonData.length; row++) {
                if (jsonData[row][0]?.startsWith('Line')) {
                  const line = jsonData[row][0];
                  if (lines.some(l => l.name === line)) {
                    runData[line] = {};
                    for (let i = 0; i < excelDates.length; i++) {
                      const date = dateMap[excelDates[i]];
                      const status = jsonData[row][i + 1];
                      runData[line][date] = status === 'Running' ? 'Yes' : 'No';
                    }
                  }
                }
              }

              let currentLine = null;
              let currentDay = null;
              const headData = {};
              for (let row = 0; row < jsonData.length; row++) {
                const firstCell = jsonData[row][0]?.toString().trim();
                if (firstCell?.startsWith('Line')) {
                  currentLine = firstCell;
                  headData[currentLine] = headData[currentLine] || {};
                } else if (firstCell?.startsWith('DAY')) {
                  const dayMatch = firstCell.match(/DAY\s+(\d+)\s+(\d+)/);
                  if (dayMatch) {
                    currentDay = dateMap[dayMatch[2]];
                    headData[currentLine][currentDay] = headData[currentLine][currentDay] || { heads: [...defaultHeadData] };
                  }
                } else if (firstCell === 'Head' && currentLine && currentDay) {
                  const dayRows = [6, 13, 20, 27, 34].map(r => r - 6);
                  const currentRowIndex = row;
                  const dayIndex = dayRows.findIndex(r => {
                    const expectedRow = jsonData.findIndex((r, i) => i >= currentRowIndex && r[0] === 'Head' && i === currentRowIndex);
                    return expectedRow === currentRowIndex;
                  });
                  if (dayIndex !== -1 && dateMap[excelDates[dayIndex]]) {
                    currentDay = dateMap[excelDates[dayIndex]];
                    headData[currentLine][currentDay] = headData[currentLine][currentDay] || { heads: [...defaultHeadData] };
                    const heads = jsonData[row].slice(1, 15).map((val, idx) => ({
                      head: idx + 1,
                      offline: val === 'X' ? 'Offline' : 'Active',
                      issue: 'None',
                      repaired: val === 'X' ? 'N/A' : 'N/A',
                      notes: ''
                    }));
                    headData[currentLine][currentDay].heads = heads;
                  }
                }
              }

              Object.keys(newData).forEach(line => {
                if (runData[line]) {
                  newData[line].running = { ...newData[line].running, ...runData[line] };
                }
              });

              Object.keys(headData).forEach(line => {
                if (newData[line]) {
                  Object.keys(headData[line]).forEach(date => {
                    newData[line][date] = headData[line][date];
                  });
                }
              });

              setData(newData);
              setError(null);
              setLoading(false);
            } catch (err) {
              console.error('File parsing error:', err);
              setError('Failed to parse Excel file. Ensure it matches the expected format.');
              setLoading(false);
            }
          };
          reader.readAsArrayBuffer(file);
        } catch (err) {
          console.error('File import error:', err);
          setError('Failed to import file. Please try again.');
          setLoading(false);
        }
      };

      const handleDateChange = (dayId, newDate) => {
        try {
          if (!newDate || newDate === '') {
            setError('Please select a valid date.');
            return;
          }

          if (dates.some(d => d.date === newDate && d.id !== dayId)) {
            setError('This date is already used for another day.');
            return;
          }

          setError(null);

          const oldDate = dates.find(d => d.id === dayId)?.date;
          if (!oldDate || oldDate === newDate) return;

          setDates(prev => prev.map(d => d.id === dayId ? { ...d, date: newDate } : d));

          setData(prev => {
            const newData = {};
            Object.keys(prev).forEach(line => {
              newData[line] = { running: {} };
              Object.keys(prev[line].running).forEach(date => {
                newData[line].running[date === oldDate ? newDate : date] = prev[line].running[date];
              });
              Object.keys(prev[line]).forEach(date => {
                if (date !== 'running') {
                  newData[line][date === oldDate ? newDate : date] = prev[line][date];
                }
              });
            });
            return newData;
          });

          if (currentDay === oldDate) {
            setCurrentDay(newDate);
          }
        } catch (e) {
          console.error('handleDateChange error:', e);
          setError('Failed to update date. Please try again.');
        }
      };

      const addToHistoryLog = (entry) => {
        setHistoryLog(prev => [
          ...prev,
          {
            ...entry,
            timestamp: new Date().toISOString(),
            id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
          }
        ]);
      };

      const deleteHistoryItem = (id) => {
        setHistoryLog(prev => prev.filter(entry => entry.id !== id));
      };

      const handleClearHistory = () => {
        try {
          if (window.confirm('Are you sure you want to clear all history entries? This action cannot be undone.')) {
            setHistoryLog([]);
            setError(null);
          }
        } catch (e) {
          console.error('handleClearHistory error:', e);
          setError('Failed to clear history. Please try again.');
        }
      };

      const handleExportHistoryToCSV = () => {
        try {
          const filteredHistoryLog = historyLog.filter(entry => {
            const matchesLine = selectedHistoryLine === 'All Lines' || entry.line === selectedHistoryLine;
            const matchesHead = selectedHistoryHead === 'All Heads' || entry.head.toString() === selectedHistoryHead;
            return matchesLine && matchesHead;
          });

          if (filteredHistoryLog.length === 0) {
            setError('No history entries to export.');
            return;
          }

          const csvData = [
            ['Timestamp', 'Line', 'Date', 'Head', 'Offline Status', 'Issue', 'Repaired', 'Notes', 'Change'],
            ...filteredHistoryLog.map(entry => [
              new Date(entry.timestamp).toLocaleString(),
              entry.line,
              entry.date,
              entry.head,
              entry.offline,
              entry.issue,
              entry.repaired,
              entry.notes || 'N/A',
              entry.change
            ])
          ];

          const csv = Papa.unparse(csvData);
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'history_log.csv';
          link.click();
          URL.revokeObjectURL(link.href);
          setError(null);
        } catch (e) {
          console.error('handleExportHistoryToCSV error:', e);
          setError('Failed to export history to CSV. Please try again.');
        }
      };

      const handleDropdownChange = (headIndex, field, value) => {
        console.log(`handleDropdownChange: headIndex=${headIndex}, field=${field}, value=${value}`);
        try {
          setData(prev => {
            const newData = { ...prev };
            const lineData = { ...newData[currentLine] };
            const dayData = { ...lineData[currentDay], heads: [...(lineData[currentDay]?.heads || defaultHeadData)] };
            const headData = { ...dayData.heads[headIndex] };

            headData[field] = value;

            if (field === 'offline' && value === 'Active') {
              headData.issue = 'None';
              headData.repaired = 'N/A';
              headData.notes = '';
            } else if (field === 'issue' && value === 'None') {
              headData.repaired = 'N/A';
            }

            dayData.heads[headIndex] = headData;
            lineData[currentDay] = dayData;
            newData[currentLine] = lineData;

            return newData;
          });
        } catch (e) {
          console.error('handleDropdownChange error:', e);
          setError('Failed to update head data. Please try again.');
        }
      };

      const handleSaveToHistory = () => {
        try {
          const heads = data[currentLine][currentDay]?.heads || defaultHeadData;
          const offlineHeads = heads.filter(head => head.offline === 'Offline');

          offlineHeads.forEach((head, index) => {
            const entry = {
              line: currentLine,
              date: currentDay,
              head: head.head,
              offline: head.offline,
              issue: head.issue,
              repaired: head.repaired,
              notes: head.notes || '',
              change: `Head ${head.head} status updated`
            };
            addToHistoryLog(entry);
          });

          pendingHistoryUpdates.current = {};

          if (offlineHeads.length === 0) {
            setError('No offline heads to save to history.');
          } else {
            setError(null);
          }
        } catch (e) {
          console.error('handleSaveToHistory error:', e);
          setError('Failed to save to history. Please try again.');
        }
      };

      const handleRunningChange = (value) => {
        try {
          console.log(`handleRunningChange: line=${currentLine}, day=${currentDay}, value=${value}`);
          setData(prev => {
            const newData = { ...prev };
            const lineData = { ...newData[currentLine], running: { ...newData[currentLine].running } };
            lineData.running[currentDay] = value;
            newData[currentLine] = lineData;
            console.log(`Updated data for ${currentLine}:`, newData[currentLine].running);
            return newData;
          });
        } catch (e) {
          console.error('handleRunningChange error:', e);
          setError('Failed to update running status. Please try again.');
        }
      };

      const handleReset = () => {
        try {
          setData(JSON.parse(JSON.stringify(initialData)));
          setDates([...initialDates]);
          setHistoryLog([]);
          setCurrentLine('Line 1');
          setCurrentDay('2025-04-13');
          setError(null);
        } catch (e) {
          console.error('handleReset error:', e);
          setError('Failed to reset data. Please try again.');
        }
      };

      const exportToCSV = () => {
        try {
          const csvData = [];
          csvData.push(['Line', 'Section', 'Date', 'Running', ...Array.from({ length: 14 }, (_, i) => [
            `Head${i + 1}_Offline`, `Head${i + 1}_Issue`, `Head${i + 1}_Repaired`, `Head${i + 1}_Notes`
          ]).flat()]);

          lines.forEach(line => {
            dates.forEach(day => {
              const row = [
                line.name,
                line.section,
                day.date,
                data[line.name].running[day.date] || 'No'
              ];
              const heads = data[line.name][day.date]?.heads || defaultHeadData;
              heads.forEach(head => {
                row.push(head.offline, head.issue, head.repaired, head.notes || '');
              });
              csvData.push(row);
            });
          });

          const csv = Papa.unparse(csvData);
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'downtime_log.csv';
          link.click();
          URL.revokeObjectURL(link.href);
        } catch (e) {
          console.error('exportToCSV error:', e);
          setError('Failed to export CSV. Please try again.');
        }
      };

      const exportToPDF = () => {
        try {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();
          doc.text('Manufacturing Downtime Log', 14, 20);
          const tableData = [];

          lines.forEach(line => {
            dates.forEach(day => {
              const heads = data[line.name][day.date]?.heads || defaultHeadData;
              heads.forEach(head => {
                tableData.push([
                  line.name,
                  line.section,
                  day.date,
                  data[line.name].running[day.date] || 'No',
                  head.head,
                  head.offline,
                  head.issue,
                  head.repaired,
                  head.notes || 'N/A'
                ]);
              });
            });
          });

          doc.autoTable({
            head: [['Line', 'Section', 'Date', 'Running', 'Head', 'Offline', 'Issue', 'Repaired', 'Notes']],
            body: tableData,
            startY: 30,
            styles: { fontSize: 8 },
            headStyles: { fillColor: [59, 130, 246] }
          });

          doc.save('downtime_log.pdf');
        } catch (e) {
          console.error('exportToPDF error:', e);
          setError('Failed to export PDF. Please try again.');
        }
      };

      const totalHeadsDown = Object.keys(data).reduce((acc, line) => {
        return acc + dates.reduce((sum, day) => {
          const heads = data[line][day.date]?.heads || defaultHeadData;
          return sum + heads.filter(head => head.offline === 'Offline').length;
        }, 0);
      }, 0);

      const totalHeadsDownPerDay = dates.map(day => ({
        day: day.label,
        heads: Object.keys(data).reduce((sum, line) => {
          const heads = data[line][day.date]?.heads || defaultHeadData;
          return sum + heads.filter(head => head.offline === 'Offline').length;
        }, 0)
      }));

      const issueCounts = issueTypes.reduce((acc, type) => {
        if (type === 'None') return acc;
        const count = Object.keys(data).reduce((sum, line) => {
          return sum + dates.reduce((daySum, day) => {
            const heads = data[line][day.date]?.heads || defaultHeadData;
            return daySum + heads.filter(head => head.issue === type).length;
          }, 0);
        }, 0);
        if (count > 0) {
          acc.push({ issue: type, count });
        }
        return acc;
      }, []);

      const activeLines = Object.keys(data).filter(line => {
        return dates.some(day => {
          const heads = data[line][day.date]?.heads || defaultHeadData;
          return heads.some(head => head.offline === 'Offline');
        });
      });

      const DaySummaryModal = ({ dayLabel }) => {
        const day = dates.find(d => d.label === dayLabel);
        if (!day) return null;

        const offlineLines = lines.reduce((acc, line) => {
          const heads = data[line.name][day.date]?.heads || defaultHeadData;
          const offlineHeads = heads.filter(head => head.offline === 'Offline');
          if (offlineHeads.length > 0) {
            acc.push({
              line: line.name,
              section: line.section,
              offlineHeads: offlineHeads.map(head => ({
                head: head.head,
                issue: head.issue,
                repaired: head.repaired,
                notes: head.notes || 'N/A'
              }))
            });
          }
          return acc;
        }, []);

        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-lg max-w-3xl w-full max-h-[80vh] overflow-y-auto">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-semibold">{dayLabel} Offline Summary</h2>
                <button
                  className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                  onClick={() => setSummaryDay(null)}
                >
                  Close
                </button>
              </div>
              {offlineLines.length === 0 ? (
                <p className="text-gray-600">No offline heads for {dayLabel}.</p>
              ) : (
                offlineLines.map(line => (
                  <div key={line.line} className="mb-4">
                    <h3 className="text-lg font-semibold">{line.section}: {line.line}</h3>
                    <table className="min-w-full bg-white mt-2">
                      <thead>
                        <tr className="bg-gray-200">
                          <th className="px-4 py-2 text-left">Head</th>
                          <th className="px-4 py-2 text-left">Issue</th>
                          <th className="px-4 py-2 text-left">Repaired</th>
                          <th className="px-4 py-2 text-left">Notes</th>
                        </tr>
                      </thead>
                      <tbody>
                        {line.offlineHeads.map(head => (
                          <tr key={head.head} className="border-t">
                            <td className="px-4 py-2">{head.head}</td>
                            <td className="px-4 py-2">{head.issue}</td>
                            <td className="px-4 py-2">{head.repaired}</td>
                            <td className="px-4 py-2">{head.notes}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                ))
              )}
            </div>
          </div>
        );
      };

      const DashboardPage = () => {
        const isLineRunning = (line, day) => {
          console.log(`Checking isLineRunning for ${line.name}, day=${day}`);
          if (selectedDashboardDay === 'All Days') {
            const isRunning = dates.some(d => {
              const status = data[line.name]?.running?.[d.date] || 'No';
              console.log(`  Day ${d.date}: status=${status}`);
              return status === 'Yes';
            });
            console.log(`  All Days result for ${line.name}: ${isRunning}`);
            return isRunning;
          }
          const status = data[line.name]?.running?.[day] || 'No';
          console.log(`  Specific day ${day} for ${line.name}: status=${status}`);
          return status === 'Yes';
        };

        console.log('Dashboard data:', JSON.stringify(data, null, 2));

        return (
          <div>
            <h2 className="text-2xl font-semibold mb-6">Dashboard</h2>
            <div className="bg-white p-6 rounded-lg shadow-md mb-8">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-semibold">Running Lines Status</h3>
                <div>
                  <label className="block text-sm font-medium mb-1">Select Day</label>
                  <select
                    className="w-full p-2 border rounded-md"
                    value={selectedDashboardDay}
                    onChange={(e) => setSelectedDashboardDay(e.target.value)}
                  >
                    <option value="All Days">All Days</option>
                    {dates.map(day => (
                      <option key={day.date} value={day.date}>
                        {day.label} ({day.date})
                      </option>
                    ))}
                  </select>
                </div>
              </div>
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                {lines.map(line => (
                  <div
                    key={line.name}
                    className={`p-4 rounded-md ${
                      isLineRunning(line, selectedDashboardDay)
                        ? 'bg-green-500 text-white'
                        : 'bg-gray-200 text-black'
                    }`}
                  >
                    <p className="font-semibold">{line.section}: {line.name}</p>
                    <p>Status: {isLineRunning(line, selectedDashboardDay) ? 'Running' : 'Not Running'}</p>
                  </div>
                ))}
              </div>
            </div>
            <div className="bg-white p-6 rounded-lg shadow-md mb-8">
              <h3 className="text-xl font-semibold mb-4">Total Heads Down Per Day (All Lines)</h3>
              <Recharts.ResponsiveContainer width="100%" height={300}>
                <Recharts.BarChart data={totalHeadsDownPerDay}>
                  <Recharts.CartesianGrid strokeDasharray="3 3" />
                  <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                  <Recharts.YAxis
                    label={{ value: 'Heads Down', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                    style={{ fontSize: 12 }}
                  />
                  <Recharts.Tooltip />
                  <Recharts.Legend />
                  <Recharts.Bar dataKey="heads" fill="#3b82f6" />
                </Recharts.BarChart>
              </Recharts.ResponsiveContainer>
            </div>
            <div className="bg-white p-6 rounded-lg shadow-md mb-8">
              <h3 className="text-xl font-semibold mb-4">Issue Distribution (All Lines)</h3>
              <Recharts.ResponsiveContainer width="100%" height={300}>
                <Recharts.PieChart>
                  <Recharts.Pie
                    data={issueCounts}
                    dataKey="count"
                    nameKey="issue"
                    cx="50%"
                    cy="50%"
                    outerRadius={80}
                    fill="#10b981"
                    label
                    style={{ fontSize: 12 }}
                  >
                    {issueCounts.map((entry, index) => (
                      <Recharts.Cell key={`cell-${index}`} fill={['#10b981', '#ef4444', '#f59e0b'][index % 3]} />
                    ))}
                  </Recharts.Pie>
                  <Recharts.Tooltip />
                  <Recharts.Legend />
                </Recharts.PieChart>
              </Recharts.ResponsiveContainer>
            </div>
          </div>
        );
      };

      const SummaryPage = () => (
        <div>
          <h2 className="text-2xl font-semibold mb-6">Summary</h2>
          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <div className="flex flex-wrap gap-4 mb-4">
              <div>
                <label className="block text-sm font-medium mb-1">Select Day for Offline Summary</label>
                <select
                  className="w-full p-2 border rounded-md"
                  value={selectedSummaryDay}
                  onChange={(e) => setSelectedSummaryDay(e.target.value)}
                >
                  <option value="All Days">All Days</option>
                  {dates.map(day => (
                    <option key={day.date} value={day.label}>{day.label}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium mb-1">Select Day for Running Lines</label>
                <select
                  className="w-full p-2 border rounded-md"
                  value={selectedRunningLinesDay}
                  onChange={(e) => setSelectedRunningLinesDay(e.target.value)}
                >
                  <option value="All Days">All Days</option>
                  {dates.map(day => (
                    <option key={day.date} value={day.label}>{day.label}</option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium mb-1">Select Issue Type</label>
                <select
                  className="w-full p-2 border rounded-md"
                  value={selectedIssueType}
                  onChange={(e) => setSelectedIssueType(e.target.value)}
                >
                  <option value="All Issues">All Issues</option>
                  {issueTypes.map(type => (
                    <option key={type} value={type}>{type}</option>
                  ))}
                </select>
              </div>
            </div>
            <div className="overflow-x-auto">
              <table className="min-w-full bg-white">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="px-4 py-2 text-left">Line</th>
                    <th className="px-4 py-2 text-left">Section</th>
                    <th className="px-4 py-2 text-left">Date</th>
                    <th className="px-4 py-2 text-left">Running</th>
                    <th className="px-4 py-2 text-left">Offline Heads</th>
                    <th className="px-4 py-2 text-left">Issues</th>
                  </tr>
                </thead>
                <tbody>
                  {lines.map(line => {
                    return dates
                      .filter(day => selectedSummaryDay === 'All Days' || day.label === selectedSummaryDay)
                      .map(day => {
                        const heads = data[line.name][day.date]?.heads || defaultHeadData;
                        const offlineHeads = heads.filter(head => head.offline === 'Offline');
                        const issues = offlineHeads
                          .filter(head => selectedIssueType === 'All Issues' || head.issue === selectedIssueType)
                          .map(head => `Head ${head.head}: ${head.issue} (${head.repaired})`);
                        if (selectedRunningLinesDay !== 'All Days' && day.label !== selectedRunningLinesDay) {
                          return null;
                        }
                        return (
                          <tr key={`${line.name}-${day.date}`} className="border-t">
                            <td className="px-4 py-2">{line.name}</td>
                            <td className="px-4 py-2">{line.section}</td>
                            <td className="px-4 py-2">{day.date}</td>
                            <td className="px-4 py-2">{data[line.name].running[day.date] || 'No'}</td>
                            <td className="px-4 py-2">{offlineHeads.length > 0 ? offlineHeads.map(h => h.head).join(', ') : 'None'}</td>
                            <td className="px-4 py-2">{issues.length > 0 ? issues.join('; ') : 'None'}</td>
                          </tr>
                        );
                      });
                  })}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      );

      const HistoryPage = () => {
        const filteredHistoryLog = historyLog.filter(entry => {
          const matchesLine = selectedHistoryLine === 'All Lines' || entry.line === selectedHistoryLine;
          const matchesHead = selectedHistoryHead === 'All Heads' || entry.head.toString() === selectedHistoryHead;
          return matchesLine && matchesHead;
        });

        return (
          <div>
            <h2 className="text-2xl font-semibold mb-6">History Log</h2>
            <div className="bg-white p-6 rounded-lg shadow-md">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-semibold">Change History</h3>
                <div className="flex gap-2">
                  <button
                    className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                    onClick={handleClearHistory}
                  >
                    Clear History
                  </button>
                  <button
                    className="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                    onClick={handleExportHistoryToCSV}
                  >
                    Export History to CSV
                  </button>
                </div>
              </div>
              <div className="flex flex-wrap gap-4 mb-4">
                <div>
                  <label className="block text-sm font-medium mb-1">Select Line</label>
                  <select
                    className="w-full p-2 border rounded-md"
                    value={selectedHistoryLine}
                    onChange={(e) => setSelectedHistoryLine(e.target.value)}
                  >
                    <option value="All Lines">All Lines</option>
                    {lines.map(line => (
                      <option key={line.name} value={line.name}>
                        {line.section}: {line.name}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1">Select Head</label>
                  <select
                    className="w-full p-2 border rounded-md"
                    value={selectedHistoryHead}
                    onChange={(e) => setSelectedHistoryHead(e.target.value)}
                  >
                    <option value="All Heads">All Heads</option>
                    {Array.from({ length: 14 }, (_, i) => i + 1).map(head => (
                      <option key={head} value={head}>{head}</option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium mb-1"> </label>
                  <button
                    className="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                    onClick={() => {
                      setSelectedHistoryLine('All Lines');
                      setSelectedHistoryHead('All Heads');
                    }}
                  >
                    View All
                  </button>
                </div>
              </div>
              {filteredHistoryLog.length === 0 ? (
                <p className="text-gray-600">
                  No history entries for {selectedHistoryLine} {selectedHistoryHead !== 'All Heads' ? `Head ${selectedHistoryHead}` : ''}.
                </p>
              ) : (
                <div className="overflow-x-auto">
                  <table className="min-w-full bg-white">
                    <thead>
                      <tr className="bg-gray-200">
                        <th className="px-4 py-2 text-left">Timestamp</th>
                        <th className="px-4 py-2 text-left">Line</th>
                        <th className="px-4 py-2 text-left">Date</th>
                        <th className="px-4 py-2 text-left">Head</th>
                        <th className="px-4 py-2 text-left">Offline Status</th>
                        <th className="px-4 py-2 text-left">Issue</th>
                        <th className="px-4 py-2 text-left">Repaired</th>
                        <th className="px-4 py-2 text-left">Notes</th>
                        <th className="px-4 py-2 text-left">Change</th>
                        <th className="px-4 py-2 text-left">Action</th>
                      </tr>
                    </thead>
                    <tbody>
                      {filteredHistoryLog.map(entry => (
                        <tr key={entry.id} className="border-t">
                          <td className="px-4 py-2">{new Date(entry.timestamp).toLocaleString()}</td>
                          <td className="px-4 py-2">{entry.line}</td>
                          <td className="px-4 py-2">{entry.date}</td>
                          <td className="px-4 py-2">{entry.head}</td>
                          <td className="px-4 py-2">{entry.offline}</td>
                          <td className="px-4 py-2">{entry.issue}</td>
                          <td className="px-4 py-2">{entry.repaired}</td>
                          <td className="px-4 py-2">{entry.notes || 'N/A'}</td>
                          <td className="px-4 py-2">{entry.change}</td>
                          <td className="px-4 py-2">
                            <button
                              className="bg-red-500 text-white px-2 py-1 rounded-md hover:bg-red-600"
                              onClick={() => deleteHistoryItem(entry.id)}
                            >
                              Delete
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          </div>
        );
      };

      const MainPage = () => (
        <div>
          {error && (
            <div className="bg-red-100 text-red-700 p-4 rounded-md mb-8">
              {error}
            </div>
          )}

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Manage Dates</h2>
              <button
                className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                onClick={handleReset}
              >
                Reset to Defaults
              </button>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
              {dates.map(day => (
                <div key={day.id}>
                  <label className="block text-sm font-medium mb-1">{day.label}</label>
                  <input
                    type="date"
                    className="w-full p-2 border rounded-md"
                    value={day.date}
                    onChange={(e) => handleDateChange(day.id, e.target.value)}
                  />
                </div>
              ))}
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Import Data</h2>
            <input
              type="file"
              accept=".csv,.xlsx"
              className="w-full p-2 border rounded-md"
              onChange={handleFileImport}
            />
            <p className="text-sm text-gray-500 mt-2">
              Upload a CSV/XLSX file with columns: Line, Section, Date, Running, Head1_Offline, Head1_Issue, Head1_Repaired, Head1_Notes, ..., Head14_Notes
            </p>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Select Line:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={currentLine}
              onChange={(e) => setCurrentLine(e.target.value)}
            >
              {lines.map(line => (
                <option key={line.name} value={line.name}>
                  {line.section}: {line.name}
                </option>
              ))}
            </select>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Select Day:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={currentDay}
              onChange={(e) => setCurrentDay(e.target.value)}
            >
              {dates.map(day => (
                <option key={day.date} value={day.date}>
                  {day.label} ({day.date})
                </option>
              ))}
            </select>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Is {currentLine} Running?</label>
            <select
              className="w-full p-2 border rounded-md"
              value={data[currentLine].running[currentDay] || 'No'}
              onChange={(e) => handleRunningChange(e.target.value)}
            >
              <option value="No">No</option>
              <option value="Yes">Yes</option>
              <option value="N/A">N/A</option>
            </select>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">
                {currentLine} - Head Status ({currentDay})
              </h2>
              <button
                className="bg-yellow-500 text-white px-4 py-2 rounded-md hover:bg-yellow-600"
                onClick={handleSaveToHistory}
              >
                Save to History
              </button>
            </div>
            <div className="overflow-x-auto">
              <table className="min-w-full bg-white">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="px-4 py-2 text-left">Head</th>
                    <th className="px-4 py-2 text-left">Offline Status</th>
                    <th className="px-4 py-2 text-left">Issue Type</th>
                    <th className="px-4 py-2 text-left">Repaired</th>
                    <th className="px-4 py-2 text-left">Notes</th>
                  </tr>
                </thead>
                <tbody>
                  {(data[currentLine][currentDay]?.heads || defaultHeadData).map((head, index) => (
                    <tr key={`head-${head.head}-${currentLine}-${currentDay}`} className="border-t">
                      <td className="px-4 py-2">{head.head}</td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.offline}
                          onChange={(e) => handleDropdownChange(index, 'offline', e.target.value)}
                        >
                          <option value="Active">Active</option>
                          <option value="Offline">Offline</option>
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.issue}
                          onChange={(e) => handleDropdownChange(index, 'issue', e.target.value)}
                          disabled={head.offline !== 'Offline'}
                        >
                          {issueTypes.map(type => (
                            <option key={type} value={type}>{type}</option>
                          ))}
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.repaired}
                          onChange={(e) => handleDropdownChange(index, 'repaired', e.target.value)}
                          disabled={head.offline !== 'Offline' || head.issue === 'None'}
                        >
                          <option value="N/A">N/A</option>
                          <option value="Fixed">Fixed</option>
                          <option value="Not Fixed">Not Fixed</option>
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <input
                          type="text"
                          className="w-full p-1 border rounded-md"
                          defaultValue={head.notes || ''}
                          ref={textareaRefs.current[index]}
                          maxLength="200"
                          placeholder="Notes (max 200 chars)"
                          disabled={head.offline !== 'Offline'}
                          onBlur={(e) => {
                            console.log(`Notes blur: head=${head.head}, value=${e.target.value}`);
                            handleDropdownChange(index, 'notes', e.target.value);
                          }}
                          onTouchStart={(e) => {
                            console.log(`Notes touch: head=${head.head}`);
                            e.target.focus();
                          }}
                          onClick={(e) => {
                            console.log(`Notes click: head=${head.head}`);
                            e.target.focus();
                          }}
                        />
                        <p className="text-xs text-gray-500 mt-1">
                          {(head.notes || '').length}/200
                        </p>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Heads Down Per Day ({currentLine})</h2>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.BarChart data={totalHeadsDownPerDay}>
                <Recharts.CartesianGrid strokeDasharray="3 3" />
                <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                <Recharts.YAxis
                  label={{ value: 'Heads Down', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                  style={{ fontSize: 12 }}
                />
                <Recharts.Tooltip />
                <Recharts.Legend />
                <Recharts.Bar dataKey="heads" fill="#3b82f6" />
              </Recharts.BarChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Issue Distribution (All Lines)</h2>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.PieChart>
                <Recharts.Pie
                  data={issueCounts}
                  dataKey="count"
                  nameKey="issue"
                  cx="50%"
                  cy="50%"
                  outerRadius={80}
                  fill="#10b981"
                  label
                  style={{ fontSize: 12 }}
                >
                  {issueCounts.map((entry, index) => (
                    <Recharts.Cell key={`cell-${index}`} fill={['#10b981', '#ef4444', '#f59e0b'][index % 3]} />
                  ))}
                </Recharts.Pie>
                <Recharts.Tooltip />
                <Recharts.Legend />
              </Recharts.PieChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Summary</h2>
              <div className="flex flex-wrap gap-2">
                {dates.map(day => (
                  <button
                    key={day.label}
                    className="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600"
                    onClick={() => setSummaryDay(day.label)}
                  >
                    {day.label} Offline Summary
                  </button>
                ))}
                <button
                  className="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                  onClick={exportToCSV}
                >
                  Export to CSV
                </button>
                <button
                  className="bg-purple-500 text-white px-4 py-2 rounded-md hover:bg-purple-600"
                  onClick={exportToPDF}
                >
                  Download PDF Report
                </button>
              </div>
            </div>
            <p className="text-gray-600">
              Total heads down across all lines and days: {totalHeadsDown}.<br />
              Issues recorded: {issueCounts.map(ic => `${ic.issue}: ${ic.count}`).join(', ') || 'None'}.<br />
              Active lines with downtime: {activeLines.length > 0 ? activeLines.join(', ') : 'None'}.<br />
              {activeLines.length > 0
                ? `Downtime is recorded across ${activeLines.length} line(s). Update statuses using the dropdowns to log new issues.`
                : `No downtime recorded. Update statuses using the dropdowns to log issues.`}
            </p>
          </div>

          {summaryDay && <DaySummaryModal dayLabel={summaryDay} />}
        </div>
      );

      if (loading) {
        return (
          <div className="text-center text-2xl font-semibold text-gray-600 mt-10">
            Loading data...
          </div>
        );
      }

      return (
        <ErrorBoundary>
          <div className="max-w-7xl mx-auto">
            <h1 className="text-3xl font-bold text-gray-800 mb-8 text-center">
              Manufacturing Downtime Logger
            </h1>

            <div className="flex mb-8">
              <button
                className={`px-4 py-2 mr-2 rounded-md ${currentPage === 'main' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('main')}
              >
                Main Logger
              </button>
              <button
                className={`px-4 py-2 mr-2 rounded-md ${currentPage === 'summary' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('summary')}
              >
                Summary Page
              </button>
              <button
                className={`px-4 py-2 mr-2 rounded-md ${currentPage === 'dashboard' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('dashboard')}
              >
                Dashboard
              </button>
              <button
                className={`px-4 py-2 rounded-md ${currentPage === 'history' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('history')}
              >
                History Log
              </button>
            </div>

            {currentPage === 'main' ? <MainPage /> : currentPage === 'dashboard' ? <DashboardPage /> : currentPage === 'history' ? <HistoryPage /> : <SummaryPage />}
          </div>
        </ErrorBoundary>
      );
    };

    try {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    } catch (e) {
      console.error('Root render error:', e);
      document.getElementById('root').innerHTML = '<div className="text-center text-red-600 p-4">Failed to load app. Please refresh and try again.</div>';
    }
  </script>
</body>
</html>
