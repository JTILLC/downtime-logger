<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Downtime Logger</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.15.0/Recharts.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
</head>
<body class="bg-gray-100 font-sans">
  <div id="root" class="container mx-auto p-4"></div>

  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function loadFileData(filename) {
      try {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row =>
            row.some(cell => cell !== '' && cell !== null && cell !== undefined)
          );
          var csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData), { header: 1 });
          return csv;
        }
        return gk_fileData[filename] || "";
      } catch (e) {
        console.error('loadFileData error:', e);
        return "";
      }
    }
  </script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    class ErrorBoundary extends React.Component {
      state = { hasError: false, error: null };

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="text-center text-red-600 p-4">
              <h2 className="text-xl font-semibold">Something went wrong!</h2>
              <p>{this.state.error?.message || 'Unknown error'}</p>
              <button
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded-md"
                onClick={() => this.setState({ hasError: false, error: null })}
              >
                Try Again
              </button>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const lines = [
      { name: 'Line 1', section: 'PC Line' }, { name: 'Line 2', section: 'PC Line' },
      { name: 'Line 3', section: 'PC Line' }, { name: 'Line 4', section: 'PC Line' },
      { name: 'Line 5', section: 'PC Line' }, { name: 'Line 6', section: 'PC Line' },
      { name: 'Line 7', section: 'PC Line' },
      { name: 'Line 8', section: 'Pellet Lines' }, { name: 'Line 9', section: 'Pellet Lines' },
      { name: 'Line 10', section: 'Pellet Lines' }, { name: 'Line 11', section: 'Pellet Lines' },
      { name: 'Line 12', section: 'Extruded' }, { name: 'Line 13', section: 'Extruded' },
      { name: 'Line 14', section: 'Extruded' }, { name: 'Line 15', section: 'Extruded' },
      { name: 'Line 16', section: 'Extruded' },
      { name: 'Line 17', section: 'Hand Kettle' }, { name: 'Line 18', section: 'Hand Kettle' },
      { name: 'Line 19', section: 'Hand Kettle' }, { name: 'Line 20', section: 'Hand Kettle' },
      { name: 'Line 21', section: 'Hand Kettle' }, { name: 'Line 22', section: 'Hand Kettle' },
      { name: 'Line 23', section: 'Hand Kettle' },
      { name: 'Line 24', section: 'Twin Screw' }, { name: 'Line 25', section: 'Twin Screw' },
      { name: 'Line 26', section: 'Twin Screw' }, { name: 'Line 27', section: 'Twin Screw' },
      { name: 'Line 28', section: 'Twin Screw' }, { name: 'Line 29', section: 'Twin Screw' },
      { name: 'Line 30', section: 'Twin Screw' }, { name: 'Line 31', section: 'Twin Screw' },
      { name: 'Line 32', section: 'Sheeted 1' }, { name: 'Line 33', section: 'Sheeted 1' },
      { name: 'Line 34', section: 'Sheeted 1' }, { name: 'Line 35', section: 'Sheeted 1' },
      { name: 'Line 36', section: 'Sheeted 1' }, { name: 'Line 37', section: 'Sheeted 1' },
      { name: 'Line 38', section: 'Sheeted 2' }, { name: 'Line 39', section: 'Sheeted 2' }
    ];

    const defaultHeadData = Array(14).fill().map((_, i) => ({
      head: i + 1,
      offline: 'Active',
      issue: 'None',
      repaired: 'N/A',
      notes: ''
    }));

    const initialData = lines.reduce((acc, line) => {
      acc[line.name] = {
        '2025-01-11': { heads: [...defaultHeadData] },
        '2025-01-15': { heads: [...defaultHeadData] },
        '2025-01-17': { heads: [...defaultHeadData] },
        '2025-02-05': { heads: [...defaultHeadData] },
        '2025-02-07': { heads: [...defaultHeadData] },
        running: {
          '2025-01-11': 'No',
          '2025-01-15': 'No',
          '2025-01-17': 'No',
          '2025-02-05': 'No',
          '2025-02-07': 'No'
        }
      };
      return acc;
    }, {});

    const initialDates = [
      { id: 'day1', date: '2025-01-11', label: 'Day 1' },
      { id: 'day2', date: '2025-01-15', label: 'Day 2' },
      { id: 'day3', date: '2025-01-17', label: 'Day 3' },
      { id: 'day4', date: '2025-02-05', label: 'Day 4' },
      { id: 'day5', date: '2025-02-07', label: 'Day 5' }
    ];

    const App = () => {
      const [data, setData] = useState(() => {
        try {
          const savedData = localStorage.getItem('downtimeLoggerData');
          return savedData ? JSON.parse(savedData) : initialData;
        } catch (e) {
          console.error('Error loading data from localStorage:', e);
          return initialData;
        }
      });
      const [dates, setDates] = useState(() => {
        try {
          const savedDates = localStorage.getItem('downtimeLoggerDates');
          return savedDates ? JSON.parse(savedDates) : initialDates;
        } catch (e) {
          console.error('Error loading dates from localStorage:', e);
          return initialDates;
        }
      });
      const [currentLine, setCurrentLine] = useState('Line 1');
      const [currentDay, setCurrentDay] = useState('2025-01-11');
      const [currentPage, setCurrentPage] = useState('main');
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [summaryDay, setSummaryDay] = useState(null);
      const [selectedSummaryDay, setSelectedSummaryDay] = useState('All Days');
      const [selectedRunningLinesDay, setSelectedRunningLinesDay] = useState('All Days');
      const [selectedIssueType, setSelectedIssueType] = useState('All Issues');

      const textareaRefs = useRef(defaultHeadData.map(() => React.createRef()));

      useEffect(() => {
        try {
          localStorage.setItem('downtimeLoggerData', JSON.stringify(data));
        } catch (e) {
          console.error('Failed to save data to localStorage:', e);
        }
      }, [data]);

      useEffect(() => {
        try {
          localStorage.setItem('downtimeLoggerDates', JSON.stringify(dates));
        } catch (e) {
          console.error('Failed to save dates to localStorage:', e);
        }
      }, [dates]);

      useEffect(() => {
        setTimeout(() => {
          setLoading(false);
        }, 500);
      }, []);

      const issueTypes = [
        'None',
        'Chute',
        'Operator',
        'Load Cell',
        'Detached Head',
        'Stepper Motor Error',
        'Hopper Issues',
        'Installed Wrong'
      ];

      const handleDateChange = (dayId, newDate) => {
        try {
          if (!newDate || newDate === '') {
            setError('Please select a valid date.');
            return;
          }

          if (dates.some(d => d.date === newDate && d.id !== dayId)) {
            setError('This date is already used for another day.');
            return;
          }

          setError(null);

          const oldDate = dates.find(d => d.id === dayId)?.date;
          if (!oldDate || oldDate === newDate) return;

          setDates(prev => prev.map(d => d.id === dayId ? { ...d, date: newDate } : d));

          setData(prev => {
            const newData = {};
            Object.keys(prev).forEach(line => {
              newData[line] = { running: {} };
              Object.keys(prev[line].running).forEach(date => {
                newData[line].running[date === oldDate ? newDate : date] = prev[line].running[date];
              });
              Object.keys(prev[line]).forEach(date => {
                if (date !== 'running') {
                  newData[line][date === oldDate ? newDate : date] = prev[line][date];
                }
              });
            });
            return newData;
          });

          if (currentDay === oldDate) {
            setCurrentDay(newDate);
          }
        } catch (e) {
          console.error('handleDateChange error:', e);
          setError('Failed to update date. Please try again.');
        }
      };

      const handleDropdownChange = (headIndex, field, value) => {
        console.log(`handleDropdownChange: headIndex=${headIndex}, field=${field}, value=${value}`);
        try {
          setData(prev => {
            const newData = { ...prev };
            const lineData = { ...newData[currentLine] };
            const dayData = { ...lineData[currentDay], heads: [...(lineData[currentDay]?.heads || defaultHeadData)] };
            const headData = { ...dayData.heads[headIndex] };

            if (field === 'notes') {
              headData.notes = value.trim();
            } else {
              headData[field] = value;
              if (field === 'offline') {
                headData.issue = value === 'Active' ? 'None' : headData.issue;
                headData.repaired = value === 'Active' ? 'N/A' : headData.repaired;
                headData.notes = value === 'Active' ? '' : headData.notes;
              }
              if (field === 'issue') {
                headData.repaired = value === 'None' ? 'N/A' : headData.repaired;
                headData.notes = value === 'None' ? '' : headData.notes;
              }
            }

            dayData.heads[headIndex] = headData;
            lineData[currentDay] = dayData;
            newData[currentLine] = lineData;
            console.log('State updated for', currentLine, currentDay, headIndex);
            return newData;
          });
        } catch (e) {
          console.error('handleDropdownChange error:', e);
          setError('Failed to update data. Please try again.');
        }
      };

      const handleRunningChange = (value) => {
        try {
          setData(prev => {
            const newData = { ...prev };
            const lineData = { ...newData[currentLine] };
            lineData.running = { ...lineData.running, [currentDay]: value };
            newData[currentLine] = lineData;
            return newData;
          });
        } catch (e) {
          console.error('handleRunningChange error:', e);
          setError('Failed to update running status. Please try again.');
        }
      };

      const handleReset = () => {
        try {
          if (window.confirm('Are you sure you want to reset all data to defaults? This will clear all changes.')) {
            setData(initialData);
            setDates(initialDates);
            setCurrentLine('Line 1');
            setCurrentDay('2025-01-11');
            setSelectedSummaryDay('All Days');
            setSelectedRunningLinesDay('All Days');
            setSelectedIssueType('All Issues');
            try {
              localStorage.removeItem('downtimeLoggerData');
              localStorage.removeItem('downtimeLoggerDates');
            } catch (e) {
              console.error('Failed to clear localStorage:', e);
            }
          }
        } catch (e) {
          console.error('handleReset error:', e);
          setError('Failed to reset data. Please try again.');
        }
      };

      const exportToCSV = () => {
        try {
          const csvData = [];
          lines.forEach(line => {
            dates.forEach(day => {
              const row = {
                Line: line.name,
                Section: line.section,
                Date: day.date,
                Running: data[line.name].running[day.date] || 'No'
              };
              (data[line.name][day.date]?.heads || defaultHeadData).forEach(head => {
                row[`Head${head.head}_Offline`] = head.offline;
                row[`Head${head.head}_Issue`] = head.issue;
                row[`Head${head.head}_Repaired`] = head.repaired;
                row[`Head${head.head}_Notes`] = head.notes || '';
              });
              csvData.push(row);
            });
          });

          const csv = Papa.unparse(csvData);
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = 'Downtime_Log.csv';
          link.click();
        } catch (e) {
          console.error('exportToCSV error:', e);
          setError('Failed to export CSV. Please try again.');
        }
      };

      const exportToPDF = () => {
        try {
          console.log('Starting PDF export for day:', selectedSummaryDay);
          if (!window.jspdf || !window.jspdf.jsPDF) {
            console.error('jsPDF not loaded');
            setError('PDF library failed to load. Please try again.');
            return;
          }

          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();
          const pageWidth = doc.internal.pageSize.getWidth();
          let yOffset = 20;

          doc.setFontSize(16);
          doc.text('Ishida CCW Downtime Report', pageWidth / 2, yOffset, { align: 'center' });
          yOffset += 10;

          doc.setFontSize(12);
          const currentDate = new Date().toLocaleString();
          console.log('Adding date to PDF:', currentDate);
          doc.text(`Generated: ${currentDate}`, pageWidth / 2, yOffset, { align: 'center' });
          yOffset += 10;

          const dayLabel = selectedSummaryDay === 'All Days' ? 'All Days' : dates.find(d => d.date === selectedSummaryDay)?.label || selectedSummaryDay;
          console.log('Adding day label to PDF:', dayLabel);
          doc.text(`Day: ${dayLabel}${selectedSummaryDay !== 'All Days' ? ` (${selectedSummaryDay})` : ''}`, 20, yOffset);
          yOffset += 10;

          doc.setFontSize(14);
          doc.text('Overall Summary', 20, yOffset);
          yOffset += 10;
          doc.setFontSize(12);
          console.log('Adding metrics: lines running=', totalLinesRunning, 'heads offline=', totalHeadsDown);
          doc.text(`Total Lines Running: ${totalLinesRunning}`, 20, yOffset);
          yOffset += 5;
          doc.text(`Total Heads Offline: ${totalHeadsDown}`, 20, yOffset);
          yOffset += 10;

          console.log('Preparing Heads Down Summary data');
          const headsDownData = headsDownSummary
            .filter(entry => selectedSummaryDay === 'All Days' || entry.date === selectedSummaryDay)
            .map(entry => [
              entry.line || 'N/A',
              entry.section || 'N/A',
              `${entry.dayLabel} (${entry.date})`,
              entry.headsOffline.map(h => h.head).join(', ') || 'None',
              entry.headsOffline.map(h => h.issue).join(', ') || 'None',
              entry.headsOffline.map(h => h.repaired).join(', ') || 'None',
              entry.headsOffline.map(h => `Head ${h.head}: ${h.notes || 'None'}`).join('; ') || 'None'
            ]);

          console.log('Heads Down data:', headsDownData);
          doc.autoTable({
            head: [['Line', 'Section', 'Day', 'Heads Offline', 'Issues', 'Repaired', 'Notes']],
            body: headsDownData.length > 0 ? headsDownData : [['No heads down recorded']],
            startY: yOffset,
            styles: { fontSize: 8, cellPadding: 2 },
            columnStyles: { 6: { cellWidth: 30 } },
            didParseCell: (data) => {
              console.log('Parsing cell:', data.section, data.row.index, data.column.index);
            }
          });
          yOffset = doc.lastAutoTable.finalY + 10;

          doc.setFontSize(14);
          doc.text('Running Lines Summary', 20, yOffset);
          yOffset += 10;
          console.log('Preparing Running Lines Summary data');
          const runningLinesData = runningLinesSummary
            .filter(entry => selectedSummaryDay === 'All Days' || entry.date === selectedSummaryDay)
            .map(entry => [
              entry.line || 'N/A',
              entry.section || 'N/A',
              `${entry.dayLabel} (${entry.date})`,
              entry.running || 'No'
            ]);

          console.log('Running Lines data:', runningLinesData);
          doc.autoTable({
            head: [['Line', 'Section', 'Day', 'Running Status']],
            body: runningLinesData.length > 0 ? runningLinesData : [['No lines running']],
            startY: yOffset,
            styles: { fontSize: 8, cellPadding: 2 },
            didParseCell: (data) => {
              console.log('Parsing cell:', data.section, data.row.index, data.column.index);
            }
          });

          const fileName = `Downtime_Report_${selectedSummaryDay === 'All Days' ? 'All_Days' : selectedSummaryDay}.pdf`;
          console.log('Saving PDF as:', fileName);
          doc.save(fileName);
          console.log('PDF export completed');
        } catch (e) {
          console.error('exportToPDF error:', e.message, e.stack);
          setError(`Failed to generate PDF: ${e.message}. Please try again.`);
        }
      };

      const handleFileImport = (event) => {
        try {
          const file = event.target.files[0];
          if (!file) return;

          const fileExtension = file.name.split('.').pop().toLowerCase();
          if (!['csv', 'xlsx'].includes(fileExtension)) {
            setError('Please upload a CSV or XLSX file.');
            return;
          }

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              let parsedData;
              if (fileExtension === 'csv') {
                parsedData = Papa.parse(e.target.result, { header: true, skipEmptyLines: true });
                if (parsedData.errors.length > 0) {
                  setError('Error parsing CSV file.');
                  return;
                }
                parsedData = parsedData.data;
              } else {
                const workbook = XLSX.read(e.target.result, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                parsedData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });
                parsedData = parsedData.slice(1).map(row => ({
                  Line: row[0],
                  Section: row[1],
                  Date: row[2],
                  Running: row[3],
                  ...Object.fromEntries(
                    Array(14).fill().flatMap((_, i) => [
                      [`Head${i + 1}_Offline`, row[4 + i * 3]],
                      [`Head${i + 1}_Issue`, row[5 + i * 3]],
                      [`Head${i + 1}_Notes`, row[6 + i * 3] || '']
                    ])
                  )
                }));
              }

              const newData = { ...initialData };
              const validLines = lines.map(l => l.name);
              const validDates = dates.map(d => d.date);

              for (const row of parsedData) {
                if (!validLines.includes(row.Line) || !validDates.includes(row.Date)) {
                  setError(`Invalid line (${row.Line}) or date (${row.Date}) in file.`);
                  return;
                }
                newData[row.Line][row.Date] = {
                  heads: Array(14).fill().map((_, i) => ({
                    head: i + 1,
                    offline: row[`Head${i + 1}_Offline`] || 'Active',
                    issue: row[`Head${i + 1}_Issue`] || 'None',
                    repaired: row[`Head${i + 1}_Repaired`] || 'N/A',
                    notes: row[`Head${i + 1}_Notes`] || ''
                  }))
                };
                newData[row.Line].running[row.Date] = row.Running || 'No';
              }

              if (window.confirm('Importing will overwrite existing data. Proceed?')) {
                setData(newData);
                setError(null);
                console.log('Imported data successfully');
              }
            } catch (err) {
              console.error('File import parsing error:', err);
              setError('Failed to parse file. Ensure correct format.');
            }
          };

          if (fileExtension === 'csv') {
            reader.readAsText(file);
          } else {
            reader.readAsArrayBuffer(file);
          }
        } catch (e) {
          console.error('handleFileImport error:', e);
          setError('Failed to import file. Please try again.');
        }
      };

      const totalHeadsDownPerDay = dates.map(day => {
        try {
          return {
            day: day.label,
            date: day.date,
            heads: (data[currentLine][day.date]?.heads || defaultHeadData).filter(head => head.offline === 'Offline').length
          };
        } catch (e) {
          console.error('totalHeadsDownPerDay error:', e);
          return { day: day.label, date: day.date, heads: 0 };
        }
      });

      const issueCounts = issueTypes
        .map(issue => {
          try {
            return {
              issue,
              count: Object.values(data)
                .flatMap(line => Object.values(line).filter(v => v.heads).flatMap(v => v.heads))
                .filter(head => head.issue === issue).length
            };
          } catch (e) {
            console.error('issueCounts error:', e);
            return { issue, count: 0 };
          }
        })
        .filter(item => item.count > 0);

      const issueTrends = dates.map(day => {
        try {
          const counts = issueTypes.reduce((acc, issue) => {
            acc[issue] = Object.values(data)
              .flatMap(line => (line[day.date]?.heads || defaultHeadData))
              .filter(head => head.issue === issue).length;
            return acc;
          }, {});
          return { day: day.label, date: day.date, ...counts };
        } catch (e) {
          console.error('issueTrends error:', e);
          return { day: day.label, date: day.date, ...issueTypes.reduce((acc, issue) => ({ ...acc, [issue]: 0 }), {}) };
        }
      });

      const totalHeadsDown = (() => {
        try {
          return Object.values(data)
            .flatMap(line => Object.values(line).filter(v => v.heads).flatMap(v => v.heads))
            .filter(head => head.offline === 'Offline').length;
        } catch (e) {
          console.error('totalHeadsDown error:', e);
          return 0;
        }
      })();

      const totalLinesRunning = lines.reduce((count, line) => {
        try {
          return count + dates.reduce((dayCount, day) =>
            dayCount + (data[line.name].running[day.date] === 'Yes' ? 1 : 0), 0);
        } catch (e) {
          console.error('totalLinesRunning error:', e);
          return count;
        }
      }, 0);

      const activeLines = lines.filter(line => {
        try {
          return Object.values(data[line.name]).some(day => day.heads && day.heads.some(head => head.offline === 'Offline'));
        } catch (e) {
          console.error('activeLines error:', e);
          return false;
        }
      }).map(line => line.name);

      const headsDownSummary = lines.flatMap(line =>
        dates.map(day => {
          try {
            const headsOffline = (data[line.name][day.date]?.heads || defaultHeadData)
              .filter(head => head.offline === 'Offline')
              .map(head => ({
                head: head.head,
                issue: head.issue,
                repaired: head.repaired,
                notes: head.notes
              }));
            return headsOffline.length > 0 ? {
              line: line.name,
              section: line.section,
              date: day.date,
              dayLabel: day.label,
              headsOffline
            } : null;
          } catch (e) {
            console.error('headsDownSummary error:', e);
            return null;
          }
        })
      ).filter(item => item);

      const runningLinesSummary = lines.flatMap(line =>
        dates.map(day => {
          try {
            return {
              line: line.name,
              section: line.section,
              date: day.date,
              dayLabel: day.label,
              running: data[line.name].running[day.date] || 'No'
            };
          } catch (e) {
            console.error('runningLinesSummary error:', e);
            return null;
          }
        })
      ).filter(item => item && item.running === 'Yes');

      const runningLinesPerDay = dates.map(day => {
        try {
          const count = runningLinesSummary.filter(entry => entry.date === day.date).length;
          console.log(`Running lines for ${day.label}: ${count}`);
          return {
            day: day.label,
            date: day.date,
            lines: count
          };
        } catch (e) {
          console.error('runningLinesPerDay error:', e);
          return { day: day.label, date: day.date, lines: 0 };
        }
      });

      const getDaySummary = (dayLabel) => {
        try {
          const dayDate = dates.find(d => d.label === dayLabel)?.date;
          if (!dayDate) return [];
          return lines.flatMap(line => {
            const headsOffline = (data[line.name][dayDate]?.heads || defaultHeadData)
              .filter(head => head.offline === 'Offline')
              .map(head => ({
                line: line.name,
                section: line.section,
                head: head.head,
                issue: head.issue,
                repaired: head.repaired,
                notes: head.notes
              }));
            return headsOffline;
          });
        } catch (e) {
          console.error('getDaySummary error:', e);
          return [];
        }
      };

      const DaySummaryModal = ({ dayLabel }) => {
        const daySummary = getDaySummary(dayLabel);
        return (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white p-6 rounded-lg shadow-lg max-w-4xl w-full max-h-[80vh] overflow-y-auto">
              <h2 className="text-xl font-semibold mb-4">{dayLabel} Offline Heads Summary</h2>
              {daySummary.length === 0 ? (
                <p className="text-gray-600">No heads offline on {dayLabel}.</p>
              ) : (
                <div className="overflow-x-auto">
                  <table className="min-w-full bg-white shadow-md rounded-lg">
                    <thead>
                      <tr className="bg-gray-200">
                        <th className="px-4 py-2 text-left">Line</th>
                        <th className="px-4 py-2 text-left">Section</th>
                        <th className="px-4 py-2 text-left">Head</th>
                        <th className="px-4 py-2 text-left">Issue</th>
                        <th className="px-4 py-2 text-left">Repaired</th>
                        <th className="px-4 py-2 text-left">Notes</th>
                      </tr>
                    </thead>
                    <tbody>
                      {daySummary.map((entry, index) => (
                        <tr key={index} className="border-t">
                          <td className="px-4 py-2">{entry.line}</td>
                          <td className="px-4 py-2">{entry.section}</td>
                          <td className="px-4 py-2">{entry.head}</td>
                          <td className="px-4 py-2">{entry.issue}</td>
                          <td className="px-4 py-2">{entry.repaired}</td>
                          <td className="px-4 py-2 max-w-xs truncate" title={entry.notes || 'None'}>
                            {entry.notes || 'None'}
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
              <button
                className="mt-4 bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                onClick={() => setSummaryDay(null)}
              >
                Close
              </button>
            </div>
          </div>
        );
      };

      const DashboardPage = () => (
        <div>
          <h2 className="text-xl font-semibold mb-4">Line Status Dashboard</h2>
          <div className="mb-4">
            <label className="block text-lg font-semibold mb-2">Select Day:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={selectedSummaryDay}
              onChange={(e) => {
                console.log('Selected dashboard day:', e.target.value);
                setSelectedSummaryDay(e.target.value);
                setSelectedRunningLinesDay(e.target.value);
              }}
            >
              <option value="All Days">All Days</option>
              {dates.map(day => (
                <option key={day.date} value={day.date}>
                  {day.label} ({day.date})
                </option>
              ))}
            </select>
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
            {lines.map(line => {
              const dayData = data[line.name][selectedSummaryDay === 'All Days' ? dates[0].date : selectedSummaryDay];
              const offlineHeads = dayData?.heads?.filter(h => h.offline === 'Offline')?.length || 0;
              const notes = dayData?.heads?.filter(h => h.notes).map(h => `Head ${h.head}: ${h.notes}`).join('; ') || 'None';
              const runningStatus = data[line.name].running[selectedSummaryDay === 'All Days' ? dates[0].date : selectedSummaryDay] || 'No';
              const bgColor = runningStatus === 'Yes' ? 'bg-green-100' : offlineHeads > 0 ? 'bg-red-100' : 'bg-gray-100';
              return (
                <div key={line.name} className={`p-4 rounded-lg shadow-md ${bgColor}`}>
                  <h3 className="text-lg font-semibold">{line.name} ({line.section})</h3>
                  <p><strong>Running:</strong> {runningStatus}</p>
                  <p><strong>Offline Heads:</strong> {offlineHeads}</p>
                  <p className="truncate" title={notes}><strong>Notes:</strong> {notes}</p>
                </div>
              );
            })}
          </div>
        </div>
      );

      const SummaryPage = () => (
        <div>
          <h2 className="text-xl font-semibold mb-4">Overall Summary</h2>
          <div className="bg-gray-50 p-4 rounded-md mb-8">
            <p className="text-gray-700">
              <strong>Total Lines Running:</strong> {totalLinesRunning} (lines marked "Yes" across all days)<br />
              <strong>Total Heads Offline:</strong> {totalHeadsDown} (heads marked "Offline" across all lines and days)
            </p>
          </div>

          <h2 className="text-xl font-semibold mb-4">Heads Down Summary</h2>
          <div className="mb-4">
            <label className="block text-lg font-semibold mb-2">Select Day:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={selectedSummaryDay}
              onChange={(e) => {
                console.log('Selected heads down summary day:', e.target.value);
                setSelectedSummaryDay(e.target.value);
                setSelectedRunningLinesDay(e.target.value);
              }}
            >
              <option value="All Days">All Days</option>
              {dates.map(day => (
                <option key={day.date} value={day.date}>
                  {day.label} ({day.date})
                </option>
              ))}
            </select>
          </div>
          {headsDownSummary.filter(entry => selectedSummaryDay === 'All Days' || entry.date === selectedSummaryDay).length === 0 ? (
            <p className="text-gray-600">No heads down recorded for {selectedSummaryDay === 'All Days' ? 'any day' : dates.find(d => d.date === selectedSummaryDay)?.label}.</p>
          ) : (
            <div className="overflow-x-auto mb-8">
              <table className="min-w-full bg-white shadow-md rounded-lg">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="px-4 py-2 text-left">Line</th>
                    <th className="px-4 py-2 text-left">Section</th>
                    <th className="px-4 py-2 text-left">Day</th>
                    <th className="px-4 py-2 text-left">Heads Offline</th>
                    <th className="px-4 py-2 text-left">Issues</th>
                    <th className="px-4 py-2 text-left">Repaired</th>
                    <th className="px-4 py-2 text-left">Notes</th>
                  </tr>
                </thead>
                <tbody>
                  {headsDownSummary
                    .filter(entry => selectedSummaryDay === 'All Days' || entry.date === selectedSummaryDay)
                    .map((entry, index) => (
                      <tr key={index} className="border-t">
                        <td className="px-4 py-2">{entry.line}</td>
                        <td className="px-4 py-2">{entry.section}</td>
                        <td className="px-4 py-2">{entry.dayLabel} ({entry.date})</td>
                        <td className="px-4 py-2">{entry.headsOffline.map(h => h.head).join(', ')}</td>
                        <td className="px-4 py-2">{entry.headsOffline.map(h => h.issue).join(', ')}</td>
                        <td className="px-4 py-2">{entry.headsOffline.map(h => h.repaired).join(', ')}</td>
                        <td className="px-4 py-2 max-w-xs truncate" title={entry.headsOffline.map(h => `Head ${h.head}: ${h.notes || 'None'}`).join('; ')}>
                          {entry.headsOffline.map(h => `Head ${h.head}: ${h.notes || 'None'}`).join('; ')}
                        </td>
                      </tr>
                    ))}
                </tbody>
              </table>
            </div>
          )}

          <h2 className="text-xl font-semibold mb-4">Running Lines Summary</h2>
          <div className="mb-4">
            <label className="block text-lg font-semibold mb-2">Select Day:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={selectedRunningLinesDay}
              onChange={(e) => {
                console.log('Selected running lines summary day:', e.target.value);
                setSelectedRunningLinesDay(e.target.value);
                setSelectedSummaryDay(e.target.value);
              }}
            >
              <option value="All Days">All Days</option>
              {dates.map(day => (
                <option key={day.date} value={day.date}>
                  {day.label} ({day.date})
                </option>
              ))}
            </select>
          </div>
          {runningLinesSummary.filter(entry => selectedRunningLinesDay === 'All Days' || entry.date === selectedRunningLinesDay).length === 0 ? (
            <p className="text-gray-600">No lines marked as running for {selectedRunningLinesDay === 'All Days' ? 'any day' : dates.find(d => d.date === selectedRunningLinesDay)?.label}.</p>
          ) : (
            <div className="overflow-x-auto mb-8">
              <table className="min-w-full bg-white shadow-md rounded-lg">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="px-4 py-2 text-left">Line</th>
                    <th className="px-4 py-2 text-left">Section</th>
                    <th className="px-4 py-2 text-left">Day</th>
                    <th className="px-4 py-2 text-left">Running Status</th>
                  </tr>
                </thead>
                <tbody>
                  {runningLinesSummary
                    .filter(entry => selectedRunningLinesDay === 'All Days' || entry.date === selectedRunningLinesDay)
                    .map((entry, index) => (
                      <tr key={index} className="border-t">
                        <td className="px-4 py-2">{entry.line}</td>
                        <td className="px-4 py-2">{entry.section}</td>
                        <td className="px-4 py-2">{entry.dayLabel} ({entry.date})</td>
                        <td className="px-4 py-2">{entry.running}</td>
                      </tr>
                    ))}
                </tbody>
              </table>
            </div>
          )}

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Running Lines Per Day</h2>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.BarChart 
                data={runningLinesPerDay.filter(day => selectedRunningLinesDay === 'All Days' || day.date === selectedRunningLinesDay)}
              >
                <Recharts.CartesianGrid strokeDasharray="3 3" />
                <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                <Recharts.YAxis
                  label={{ value: 'Lines Running', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                  style={{ fontSize: 12 }}
                />
                <Recharts.Tooltip />
                <Recharts.Legend />
                <Recharts.Bar dataKey="lines" fill="#3b82f6" />
              </Recharts.BarChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Issue Trends Over Time</h2>
            <div className="mb-4">
              <label className="block text-lg font-semibold mb-2">Select Issue Type:</label>
              <select
                className="w-full p-2 border rounded-md"
                value={selectedIssueType}
                onChange={(e) => {
                  console.log('Selected issue type:', e.target.value);
                  setSelectedIssueType(e.target.value);
                }}
              >
                <option value="All Issues">All Issues</option>
                {issueTypes.filter(issue => issue !== 'None').map(issue => (
                  <option key={issue} value={issue}>{issue}</option>
                ))}
              </select>
            </div>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.LineChart data={issueTrends}>
                <Recharts.CartesianGrid strokeDasharray="3 3" />
                <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                <Recharts.YAxis
                  label={{ value: 'Issue Count', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                  style={{ fontSize: 12 }}
                />
                <Recharts.Tooltip />
                <Recharts.Legend />
                {issueTypes
                  .filter(issue => issue !== 'None' && (selectedIssueType === 'All Issues' || selectedIssueType === issue))
                  .map((issue, index) => (
                    <Recharts.Line
                      key={issue}
                      type="monotone"
                      dataKey={issue}
                      stroke={['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#f97316'][index % 7]}
                      name={issue}
                    />
                  ))}
              </Recharts.LineChart>
            </Recharts.ResponsiveContainer>
          </div>
        </div>
      );

      const MainPage = () => (
        <div>
          {error && (
            <div className="bg-red-100 text-red-700 p-4 rounded-md mb-8">
              {error}
            </div>
          )}

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Manage Dates</h2>
              <button
                className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                onClick={handleReset}
              >
                Reset to Defaults
              </button>
            </div>
            <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
              {dates.map(day => (
                <div key={day.id}>
                  <label className="block text-sm font-medium mb-1">{day.label}</label>
                  <input
                    type="date"
                    className="w-full p-2 border rounded-md"
                    value={day.date}
                    onChange={(e) => handleDateChange(day.id, e.target.value)}
                  />
                </div>
              ))}
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Import Data</h2>
            <input
              type="file"
              accept=".csv,.xlsx"
              className="w-full p-2 border rounded-md"
              onChange={handleFileImport}
            />
            <p className="text-sm text-gray-500 mt-2">
              Upload a CSV/XLSX file with columns: Line, Section, Date, Running, Head1_Offline, Head1_Issue, Head1_Repaired, Head1_Notes, ..., Head14_Notes
            </p>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Select Line:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={currentLine}
              onChange={(e) => setCurrentLine(e.target.value)}
            >
              {lines.map(line => (
                <option key={line.name} value={line.name}>
                  {line.section}: {line.name}
                </option>
              ))}
            </select>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Select Day:</label>
            <select
              className="w-full p-2 border rounded-md"
              value={currentDay}
              onChange={(e) => setCurrentDay(e.target.value)}
            >
              {dates.map(day => (
                <option key={day.date} value={day.date}>
                  {day.label} ({day.date})
                </option>
              ))}
            </select>
          </div>

          <div className="mb-8">
            <label className="block text-lg font-semibold mb-2">Is {currentLine} Running?</label>
            <select
              className="w-full p-2 border rounded-md"
              value={data[currentLine].running[currentDay] || 'No'}
              onChange={(e) => handleRunningChange(e.target.value)}
            >
              <option value="No">No</option>
              <option value="Yes">Yes</option>
              <option value="N/A">N/A</option>
            </select>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">
              {currentLine} - Head Status ({currentDay})
            </h2>
            <div className="overflow-x-auto">
              <table className="min-w-full bg-white">
                <thead>
                  <tr className="bg-gray-200">
                    <th className="px-4 py-2 text-left">Head</th>
                    <th className="px-4 py-2 text-left">Offline Status</th>
                    <th className="px-4 py-2 text-left">Issue Type</th>
                    <th className="px-4 py-2 text-left">Repaired</th>
                    <th className="px-4 py-2 text-left">Notes</th>
                  </tr>
                </thead>
                <tbody>
                  {(data[currentLine][currentDay]?.heads || defaultHeadData).map((head, index) => (
                    <tr key={`head-${head.head}-${currentLine}-${currentDay}`} className="border-t">
                      <td className="px-4 py-2">{head.head}</td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.offline}
                          onChange={(e) => handleDropdownChange(index, 'offline', e.target.value)}
                        >
                          <option value="Active">Active</option>
                          <option value="Offline">Offline</option>
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.issue}
                          onChange={(e) => handleDropdownChange(index, 'issue', e.target.value)}
                          disabled={head.offline !== 'Offline'}
                        >
                          {issueTypes.map(type => (
                            <option key={type} value={type}>{type}</option>
                          ))}
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <select
                          className="w-full p-1 border rounded-md"
                          value={head.repaired}
                          onChange={(e) => handleDropdownChange(index, 'repaired', e.target.value)}
                          disabled={head.offline !== 'Offline' || head.issue === 'None'}
                        >
                          <option value="N/A">N/A</option>
                          <option value="Fixed">Fixed</option>
                          <option value="Not Fixed">Not Fixed</option>
                        </select>
                      </td>
                      <td className="px-4 py-2">
                        <input
                          type="text"
                          className="w-full p-1 border rounded-md"
                          defaultValue={head.notes || ''}
                          ref={textareaRefs.current[index]}
                          maxLength="200"
                          placeholder="Notes (max 200 chars)"
                          disabled={head.offline !== 'Offline'}
                          onBlur={(e) => {
                            console.log(`Notes blur: head=${head.head}, value=${e.target.value}`);
                            handleDropdownChange(index, 'notes', e.target.value);
                          }}
                          onTouchStart={(e) => {
                            console.log(`Notes touch: head=${head.head}`);
                            e.target.focus();
                          }}
                          onClick={(e) => {
                            console.log(`Notes click: head=${head.head}`);
                            e.target.focus();
                          }}
                        />
                        <p className="text-xs text-gray-500 mt-1">
                          {(head.notes || '').length}/200
                        </p>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Heads Down Per Day ({currentLine})</h2>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.BarChart data={totalHeadsDownPerDay}>
                <Recharts.CartesianGrid strokeDasharray="3 3" />
                <Recharts.XAxis dataKey="day" style={{ fontSize: 12 }} />
                <Recharts.YAxis
                  label={{ value: 'Heads Down', angle: -90, position: 'insideLeft', style: { fontSize: 12 } }}
                  style={{ fontSize: 12 }}
                />
                <Recharts.Tooltip />
                <Recharts.Legend />
                <Recharts.Bar dataKey="heads" fill="#3b82f6" />
              </Recharts.BarChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 className="text-xl font-semibold mb-4">Issue Distribution (All Lines)</h2>
            <Recharts.ResponsiveContainer width="100%" height={300}>
              <Recharts.PieChart>
                <Recharts.Pie
                  data={issueCounts}
                  dataKey="count"
                  nameKey="issue"
                  cx="50%"
                  cy="50%"
                  outerRadius={80}
                  fill="#10b981"
                  label
                  style={{ fontSize: 12 }}
                >
                  {issueCounts.map((entry, index) => (
                    <Recharts.Cell key={`cell-${index}`} fill={['#10b981', '#ef4444', '#f59e0b'][index % 3]} />
                  ))}
                </Recharts.Pie>
                <Recharts.Tooltip />
                <Recharts.Legend />
              </Recharts.PieChart>
            </Recharts.ResponsiveContainer>
          </div>

          <div className="bg-white p-6 rounded-lg shadow-md">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Summary</h2>
              <div className="flex flex-wrap gap-2">
                {dates.map(day => (
                  <button
                    key={day.label}
                    className="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600"
                    onClick={() => setSummaryDay(day.label)}
                  >
                    {day.label} Offline Summary
                  </button>
                ))}
                <button
                  className="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600"
                  onClick={exportToCSV}
                >
                  Export to CSV
                </button>
                <button
                  className="bg-purple-500 text-white px-4 py-2 rounded-md hover:bg-purple-600"
                  onClick={exportToPDF}
                >
                  Download PDF Report
                </button>
              </div>
            </div>
            <p className="text-gray-600">
              Total heads down across all lines and days: {totalHeadsDown}.<br />
              Issues recorded: {issueCounts.map(ic => `${ic.issue}: ${ic.count}`).join(', ') || 'None'}.<br />
              Active lines with downtime: {activeLines.length > 0 ? activeLines.join(', ') : 'None'}.<br />
              {activeLines.length > 0
                ? `Downtime is recorded across ${activeLines.length} line(s). Update statuses using the dropdowns to log new issues.`
                : `No downtime recorded. Update statuses using the dropdowns to log issues.`}
            </p>
          </div>

          {summaryDay && <DaySummaryModal dayLabel={summaryDay} />}
        </div>
      );

      if (loading) {
        return (
          <div className="text-center text-2xl font-semibold text-gray-600 mt-10">
            Loading data...
          </div>
        );
      }

      return (
        <ErrorBoundary>
          <div className="max-w-7xl mx-auto">
            <h1 className="text-3xl font-bold text-gray-800 mb-8 text-center">
              Manufacturing Downtime Logger
            </h1>

            <div className="flex mb-8">
              <button
                className={`px-4 py-2 mr-2 rounded-md ${currentPage === 'main' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('main')}
              >
                Main Logger
              </button>
              <button
                className={`px-4 py-2 mr-2 rounded-md ${currentPage === 'summary' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('summary')}
              >
                Summary Page
              </button>
              <button
                className={`px-4 py-2 rounded-md ${currentPage === 'dashboard' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}
                onClick={() => setCurrentPage('dashboard')}
              >
                Dashboard
              </button>
            </div>

            {currentPage === 'main' ? <MainPage /> : currentPage === 'dashboard' ? <DashboardPage /> : <SummaryPage />}
          </div>
        </ErrorBoundary>
      );
    };

    try {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    } catch (e) {
      console.error('Root render error:', e);
      document.getElementById('root').innerHTML = '<div className="text-center text-red-600 p-4">Failed to load app. Please refresh and try again.</div>';
    }
  </script>
</body>
</html>
